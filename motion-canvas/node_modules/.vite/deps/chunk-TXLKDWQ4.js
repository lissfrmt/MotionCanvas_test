import {
  CompoundSignalContext,
  SignalContext,
  Vector2,
  capitalize,
  createComputed,
  createSignal,
  deepLerp,
  import_chroma_js,
  isReactive,
  map,
  transformScalar,
  useLogger
} from "./chunk-ZOQDAVQN.js";

// node_modules/@motion-canvas/2d/lib/partials/Filter.js
var FILTERS = {
  invert: {
    name: "invert"
  },
  sepia: {
    name: "sepia"
  },
  grayscale: {
    name: "grayscale"
  },
  brightness: {
    name: "brightness",
    default: 1
  },
  contrast: {
    name: "contrast",
    default: 1
  },
  saturate: {
    name: "saturate",
    default: 1
  },
  hue: {
    name: "hue-rotate",
    unit: "deg",
    scale: 1
  },
  blur: {
    name: "blur",
    transform: true,
    unit: "px",
    scale: 1
  }
};
var Filter = class {
  get name() {
    return this.props.name;
  }
  get default() {
    return this.props.default;
  }
  constructor(props) {
    this.props = {
      name: "invert",
      default: 0,
      unit: "%",
      scale: 100,
      transform: false,
      ...props,
      value: props.value ?? props.default ?? 0
    };
    this.value = createSignal(this.props.value, map, this);
  }
  isActive() {
    return this.value() !== this.props.default;
  }
  serialize(matrix) {
    let value = this.value();
    if (this.props.transform) {
      value = transformScalar(value, matrix);
    }
    return `${this.props.name}(${value * this.props.scale}${this.props.unit})`;
  }
};
function invert(value) {
  return new Filter({ ...FILTERS.invert, value });
}
function sepia(value) {
  return new Filter({ ...FILTERS.sepia, value });
}
function grayscale(value) {
  return new Filter({ ...FILTERS.grayscale, value });
}
function brightness(value) {
  return new Filter({ ...FILTERS.brightness, value });
}
function contrast(value) {
  return new Filter({ ...FILTERS.contrast, value });
}
function saturate(value) {
  return new Filter({ ...FILTERS.saturate, value });
}
function hue(value) {
  return new Filter({ ...FILTERS.hue, value });
}
function blur(value) {
  return new Filter({ ...FILTERS.blur, value });
}

// node_modules/@motion-canvas/2d/lib/decorators/initializers.js
var INITIALIZERS = Symbol.for("@motion-canvas/2d/decorators/initializers");
function addInitializer(target, initializer) {
  if (!target[INITIALIZERS]) {
    target[INITIALIZERS] = [];
  } else if (
    // if one of the prototypes has initializers
    target[INITIALIZERS] && // and it's not the target object itself
    !Object.prototype.hasOwnProperty.call(target, INITIALIZERS)
  ) {
    const base = Object.getPrototypeOf(target);
    target[INITIALIZERS] = [...base[INITIALIZERS]];
  }
  target[INITIALIZERS].push(initializer);
}
function initialize(target, context) {
  if (target[INITIALIZERS]) {
    try {
      target[INITIALIZERS].forEach((initializer) => initializer(target, context));
    } catch (e) {
      e.inspect ?? (e.inspect = target.key);
      throw e;
    }
  }
}

// node_modules/@motion-canvas/2d/lib/utils/patchSignal.js
function patchSignal(signal2, parser2, owner, name) {
  if (parser2) {
    signal2.setParser(parser2.bind(owner));
  }
  if (name && owner) {
    const setter = owner == null ? void 0 : owner[`set${capitalize(name)}`];
    if (setter) {
      signal2.set = (...args) => {
        setter.apply(owner, args);
        return owner;
      };
    }
    const getter = owner == null ? void 0 : owner[`get${capitalize(name)}`];
    if (getter) {
      signal2.get = getter.bind(owner);
    }
    const tweener = owner == null ? void 0 : owner[`tween${capitalize(name)}`];
    if (tweener) {
      signal2.doTween = tweener.bind(owner);
    }
  }
}

// node_modules/@motion-canvas/2d/lib/decorators/signal.js
var PROPERTIES = Symbol.for("@motion-canvas/2d/decorators/properties");
function getPropertyMeta(object, key) {
  var _a;
  return ((_a = object[PROPERTIES]) == null ? void 0 : _a[key]) ?? null;
}
function getPropertyMetaOrCreate(object, key) {
  let lookup;
  if (!object[PROPERTIES]) {
    object[PROPERTIES] = lookup = {};
  } else if (object[PROPERTIES] && !Object.prototype.hasOwnProperty.call(object, PROPERTIES)) {
    object[PROPERTIES] = lookup = Object.fromEntries(Object.entries(object[PROPERTIES]).map(([key2, meta]) => [key2, { ...meta }]));
  } else {
    lookup = object[PROPERTIES];
  }
  lookup[key] ?? (lookup[key] = {
    cloneable: true,
    inspectable: true,
    compoundEntries: []
  });
  return lookup[key];
}
function getPropertiesOf(value) {
  if (value && typeof value === "object") {
    return value[PROPERTIES] ?? {};
  }
  return {};
}
function initializeSignals(instance, props) {
  initialize(instance);
  for (const [key, meta] of Object.entries(getPropertiesOf(instance))) {
    const signal2 = instance[key];
    signal2.reset();
    if (props[key] !== void 0) {
      signal2(props[key]);
    }
    if (meta.compoundEntries !== void 0) {
      for (const [key2, property] of meta.compoundEntries) {
        if (property in props) {
          signal2[key2](props[property]);
        }
      }
    }
  }
}
function signal() {
  return (target, key) => {
    const meta = getPropertyMetaOrCreate(target, key);
    addInitializer(target, (instance) => {
      var _a;
      const getDefault = (_a = instance[`getDefault${capitalize(key)}`]) == null ? void 0 : _a.bind(instance);
      const signal2 = new SignalContext(getDefault ?? meta.default, meta.interpolationFunction ?? deepLerp, instance);
      patchSignal(signal2, meta.parser, instance, key);
      instance[key] = signal2.toSignal();
    });
  };
}
function initial(value) {
  return (target, key) => {
    const meta = getPropertyMeta(target, key);
    if (!meta) {
      useLogger().error(`Missing property decorator for "${key.toString()}"`);
      return;
    }
    meta.default = value;
  };
}
function interpolation(value) {
  return (target, key) => {
    const meta = getPropertyMeta(target, key);
    if (!meta) {
      useLogger().error(`Missing property decorator for "${key.toString()}"`);
      return;
    }
    meta.interpolationFunction = value;
  };
}
function parser(value) {
  return (target, key) => {
    const meta = getPropertyMeta(target, key);
    if (!meta) {
      useLogger().error(`Missing property decorator for "${key.toString()}"`);
      return;
    }
    meta.parser = value;
  };
}
function wrapper(value) {
  return (target, key) => {
    const meta = getPropertyMeta(target, key);
    if (!meta) {
      useLogger().error(`Missing property decorator for "${key.toString()}"`);
      return;
    }
    meta.parser = (raw) => new value(raw);
    if ("lerp" in value) {
      meta.interpolationFunction ?? (meta.interpolationFunction = value.lerp);
    }
  };
}
function cloneable(value = true) {
  return (target, key) => {
    const meta = getPropertyMeta(target, key);
    if (!meta) {
      useLogger().error(`Missing property decorator for "${key.toString()}"`);
      return;
    }
    meta.cloneable = value;
  };
}
function inspectable(value = true) {
  return (target, key) => {
    const meta = getPropertyMeta(target, key);
    if (!meta) {
      useLogger().error(`Missing property decorator for "${key.toString()}"`);
      return;
    }
    meta.inspectable = value;
  };
}

// node_modules/@motion-canvas/2d/lib/decorators/compound.js
function compound(entries) {
  return (target, key) => {
    const meta = getPropertyMetaOrCreate(target, key);
    meta.compound = true;
    meta.compoundEntries = Object.entries(entries);
    addInitializer(target, (instance) => {
      if (!meta.parser) {
        useLogger().error(`Missing parser decorator for "${key.toString()}"`);
        return;
      }
      const signalContext = new CompoundSignalContext(Object.keys(entries), meta.parser, meta.default, meta.interpolationFunction ?? deepLerp, instance);
      patchSignal(signalContext, meta.parser, instance, key);
      const signal2 = signalContext.toSignal();
      for (const [key2, property] of meta.compoundEntries) {
        patchSignal(signal2[key2].context, void 0, instance, property);
      }
      instance[key] = signal2;
    });
  };
}

// node_modules/@motion-canvas/2d/lib/decorators/vector2Signal.js
function vector2Signal(prefix) {
  return (target, key) => {
    compound(typeof prefix === "object" ? prefix : {
      x: prefix ? `${prefix}X` : "x",
      y: prefix ? `${prefix}Y` : "y"
    })(target, key);
    wrapper(Vector2)(target, key);
  };
}

// node_modules/@motion-canvas/2d/lib/decorators/computed.js
function computed() {
  return (target, key) => {
    addInitializer(target, (instance) => {
      const method = Object.getPrototypeOf(instance)[key];
      instance[key] = createComputed(method.bind(instance), instance);
    });
  };
}

// node_modules/@motion-canvas/2d/lib/partials/Gradient.js
var __decorate = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var Gradient = class {
  constructor(props) {
    initializeSignals(this, props);
  }
  canvasGradient(context) {
    let gradient;
    switch (this.type()) {
      case "linear":
        gradient = context.createLinearGradient(this.from.x(), this.from.y(), this.to.x(), this.to.y());
        break;
      case "conic":
        gradient = context.createConicGradient(this.angle(), this.from.x(), this.from.y());
        break;
      case "radial":
        gradient = context.createRadialGradient(this.from.x(), this.from.y(), this.fromRadius(), this.to.x(), this.to.y(), this.toRadius());
        break;
    }
    for (const { offset, color } of this.stops()) {
      gradient.addColorStop(isReactive(offset) ? offset() : offset, new import_chroma_js.Color(isReactive(color) ? color() : color).serialize());
    }
    return gradient;
  }
};
__decorate([
  initial("linear"),
  signal()
], Gradient.prototype, "type", void 0);
__decorate([
  vector2Signal("from")
], Gradient.prototype, "from", void 0);
__decorate([
  vector2Signal("to")
], Gradient.prototype, "to", void 0);
__decorate([
  initial(0),
  signal()
], Gradient.prototype, "angle", void 0);
__decorate([
  initial(0),
  signal()
], Gradient.prototype, "fromRadius", void 0);
__decorate([
  initial(0),
  signal()
], Gradient.prototype, "toRadius", void 0);
__decorate([
  initial([]),
  signal()
], Gradient.prototype, "stops", void 0);
__decorate([
  computed()
], Gradient.prototype, "canvasGradient", null);

// node_modules/@motion-canvas/2d/lib/partials/Pattern.js
var __decorate2 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var Pattern = class {
  constructor(props) {
    initializeSignals(this, props);
  }
  canvasPattern(context) {
    return context.createPattern(this.image(), this.repetition());
  }
};
__decorate2([
  signal()
], Pattern.prototype, "image", void 0);
__decorate2([
  initial(null),
  signal()
], Pattern.prototype, "repetition", void 0);
__decorate2([
  computed()
], Pattern.prototype, "canvasPattern", null);

export {
  addInitializer,
  getPropertyMetaOrCreate,
  getPropertiesOf,
  initializeSignals,
  signal,
  initial,
  interpolation,
  parser,
  wrapper,
  cloneable,
  inspectable,
  FILTERS,
  Filter,
  invert,
  sepia,
  grayscale,
  brightness,
  contrast,
  saturate,
  hue,
  blur,
  compound,
  vector2Signal,
  computed,
  Gradient,
  Pattern
};
//# sourceMappingURL=chunk-TXLKDWQ4.js.map
