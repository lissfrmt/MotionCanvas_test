import {
  BoolMetaField,
  ColorMetaField,
  EnumMetaField,
  ExporterMetaField,
  MetaField,
  NumberMetaField,
  ObjectMetaField,
  PlaybackManager,
  PlaybackState,
  RangeMetaField,
  Semaphore,
  Vector2,
  Vector2MetaField,
  clamp,
  getContext,
  useLogger
} from "./chunk-ZOQDAVQN.js";
import {
  AsyncEventDispatcher,
  EventDispatcher,
  ValueDispatcher
} from "./chunk-3QXD73V2.js";

// node_modules/@motion-canvas/core/lib/app/presets.js
var Scales = [
  { value: 0.25, text: "0.25x (Quarter)" },
  { value: 0.5, text: `0.5x (Half)` },
  { value: 1, text: `1.0x (Full)` },
  { value: 2, text: `2.0x (Double)` }
];
var ColorSpaces = [
  { value: "srgb", text: "sRGB" },
  { value: "display-p3", text: "DCI-P3" }
];
var FileTypes = [
  { value: "image/png", text: "png" },
  { value: "image/jpeg", text: "jpeg" },
  { value: "image/webp", text: "webp" }
];
var FrameRates = [
  { value: 30, text: "30 FPS" },
  { value: 60, text: "60 FPS" }
];

// node_modules/@motion-canvas/core/lib/app/ImageExporter.js
var EXPORT_FRAME_LIMIT = 256;
var EXPORT_RETRY_DELAY = 1e3;
var ImageExporter = class {
  constructor(logger) {
    this.logger = logger;
    this.name = "image sequence";
    this.frameLookup = /* @__PURE__ */ new Map();
    this.frameCounter = 0;
    this.projectName = "unknown";
    this.quality = 1;
    this.fileType = "image/png";
    this.groupByScene = false;
    if (import.meta.hot) {
      import.meta.hot.on("motion-canvas:export-ack", ({ frame }) => {
        var _a;
        (_a = this.frameLookup.get(frame)) == null ? void 0 : _a();
      });
    }
  }
  meta() {
    const meta = new ObjectMetaField(this.name, {
      fileType: new EnumMetaField("file type", FileTypes),
      quality: new NumberMetaField("quality", 100).setRange(0, 100),
      groupByScene: new BoolMetaField("group by scene", false)
    });
    meta.fileType.onChanged.subscribe((value) => {
      meta.quality.disable(value === "image/png");
    });
    return meta;
  }
  async configure(settings) {
    const options = settings.exporter.options;
    this.projectName = settings.name;
    this.quality = clamp(0, 1, options.quality / 100);
    this.fileType = options.fileType;
    this.groupByScene = options.groupByScene;
  }
  async start() {
    this.frameLookup.clear();
  }
  async handleFrame(canvas, frame, sceneFrame, sceneName, signal) {
    if (this.frameLookup.has(frame)) {
      this.logger.warn(`Frame no. ${frame} is already being exported.`);
      return;
    }
    if (import.meta.hot) {
      while (this.frameCounter > EXPORT_FRAME_LIMIT) {
        await new Promise((resolve) => setTimeout(resolve, EXPORT_RETRY_DELAY));
        if (signal.aborted) {
          return;
        }
      }
      this.frameCounter++;
      this.frameLookup.set(frame, () => {
        this.frameCounter--;
        this.frameLookup.delete(frame);
      });
      import.meta.hot.send("motion-canvas:export", {
        frame,
        sceneFrame,
        data: canvas.toDataURL(this.fileType, this.quality),
        mimeType: this.fileType,
        subDirectories: this.groupByScene ? [this.projectName, sceneName] : [this.projectName],
        groupByScene: this.groupByScene
      });
    }
  }
  async stop() {
    while (this.frameCounter > 0) {
      await new Promise((resolve) => setTimeout(resolve, EXPORT_RETRY_DELAY));
    }
  }
};

// node_modules/@motion-canvas/core/lib/app/Logger.js
var LogLevel;
(function(LogLevel2) {
  LogLevel2["Error"] = "error";
  LogLevel2["Warn"] = "warn";
  LogLevel2["Info"] = "info";
  LogLevel2["Http"] = "http";
  LogLevel2["Verbose"] = "verbose";
  LogLevel2["Debug"] = "debug";
  LogLevel2["Silly"] = "silly";
})(LogLevel || (LogLevel = {}));
var Logger = class {
  constructor() {
    this.logged = new EventDispatcher();
    this.history = [];
    this.profilers = {};
  }
  /**
   * Triggered when a new message is logged.
   */
  get onLogged() {
    return this.logged.subscribable;
  }
  log(payload) {
    this.logged.dispatch(payload);
    this.history.push(payload);
  }
  error(payload) {
    this.logLevel(LogLevel.Error, payload);
  }
  warn(payload) {
    this.logLevel(LogLevel.Warn, payload);
  }
  info(payload) {
    this.logLevel(LogLevel.Info, payload);
  }
  http(payload) {
    this.logLevel(LogLevel.Http, payload);
  }
  verbose(payload) {
    this.logLevel(LogLevel.Verbose, payload);
  }
  debug(payload) {
    this.logLevel(LogLevel.Debug, payload);
  }
  silly(payload) {
    this.logLevel(LogLevel.Silly, payload);
  }
  logLevel(level, payload) {
    const result = typeof payload === "string" ? { message: payload } : payload;
    result.level = level;
    this.log(result);
  }
  profile(id, payload) {
    const time = performance.now();
    if (this.profilers[id]) {
      const timeEnd = this.profilers[id];
      delete this.profilers[id];
      const result = payload ?? { message: id };
      result.level ?? (result.level = LogLevel.Debug);
      result.durationMs = time - timeEnd;
      this.log(result);
      return;
    }
    this.profilers[id] = time;
  }
};

// node_modules/@motion-canvas/core/lib/app/PlaybackStatus.js
var PlaybackStatus = class {
  constructor(playback) {
    this.playback = playback;
  }
  /**
   * Convert seconds to frames using the current framerate.
   *
   * @param seconds - The seconds to convert.
   */
  secondsToFrames(seconds) {
    return Math.ceil(seconds * this.playback.fps);
  }
  /**
   * Convert frames to seconds using the current framerate.
   *
   * @param seconds - The frames to convert.
   */
  framesToSeconds(frames) {
    return frames / this.playback.fps;
  }
  get time() {
    return this.framesToSeconds(this.playback.frame);
  }
  get frame() {
    return this.playback.frame;
  }
  get speed() {
    return this.playback.speed;
  }
  get fps() {
    return this.playback.fps;
  }
  get state() {
    return this.playback.state;
  }
};

// node_modules/@motion-canvas/core/lib/media/AudioManager.js
var AudioManager = class {
  get onDataChanged() {
    return this.data.subscribable;
  }
  constructor(logger) {
    this.logger = logger;
    this.data = new ValueDispatcher(null);
    this.context = new AudioContext();
    this.audioElement = new Audio();
    this.source = null;
    this.error = false;
    this.abortController = null;
    this.offset = 0;
    if (import.meta.hot) {
      import.meta.hot.on("motion-canvas:assets", ({ urls }) => {
        if (this.source && urls.includes(this.source)) {
          this.setSource(this.source);
        }
      });
    }
  }
  getTime() {
    return this.toAbsoluteTime(this.audioElement.currentTime);
  }
  setTime(value) {
    this.audioElement.currentTime = this.toRelativeTime(value);
  }
  setOffset(value) {
    this.offset = value;
  }
  setMuted(isMuted) {
    this.audioElement.muted = isMuted;
  }
  setSource(src) {
    var _a;
    this.source = src;
    this.audioElement.src = src;
    (_a = this.abortController) == null ? void 0 : _a.abort();
    this.abortController = new AbortController();
    this.loadData(this.abortController.signal).catch((e) => {
      if (e.name !== "AbortError") {
        this.logger.error(e);
      }
    });
  }
  isInRange(time) {
    return time >= this.offset && time < this.audioElement.duration;
  }
  toRelativeTime(time) {
    return Math.max(0, time - this.offset);
  }
  toAbsoluteTime(time) {
    return time + this.offset;
  }
  isReady() {
    return this.source && !this.error;
  }
  /**
   * Pause/resume the audio.
   *
   * @param isPaused - Whether the audio should be paused or resumed.
   *
   * @returns `true` if the audio successfully started playing.
   */
  async setPaused(isPaused) {
    if (this.source && this.audioElement.paused !== isPaused) {
      if (isPaused) {
        this.audioElement.pause();
      } else {
        try {
          await this.audioElement.play();
          this.error = false;
          return true;
        } catch (e) {
          if (!this.error) {
            useLogger().error(e);
          }
          this.error = true;
        }
      }
    }
    return false;
  }
  async loadData(signal) {
    this.data.current = null;
    if (!this.source) {
      return;
    }
    const response = await fetch(this.source, { signal });
    const rawBuffer = await response.arrayBuffer();
    if (signal.aborted)
      return;
    const audioBuffer = await this.decodeAudioData(rawBuffer);
    if (signal.aborted)
      return;
    const sampleSize = 256;
    const samples = ~~(audioBuffer.length / sampleSize);
    const peaks = [];
    let absoluteMax = 0;
    for (let channelId = 0; channelId < audioBuffer.numberOfChannels; channelId++) {
      const channel = audioBuffer.getChannelData(channelId);
      for (let i = 0; i < samples; i++) {
        const start = ~~(i * sampleSize);
        const end = ~~(start + sampleSize);
        let min = channel[start];
        let max = min;
        for (let j = start; j < end; j++) {
          const value = channel[j];
          if (value > max) {
            max = value;
          }
          if (value < min) {
            min = value;
          }
        }
        if (channelId === 0 || max > peaks[i * 2]) {
          peaks[i * 2] = max;
        }
        if (channelId === 0 || min < peaks[i * 2 + 1]) {
          peaks[i * 2 + 1] = min;
        }
        if (max > absoluteMax) {
          absoluteMax = max;
        }
        if (Math.abs(min) > absoluteMax) {
          absoluteMax = Math.abs(min);
        }
      }
    }
    this.data.current = {
      peaks,
      absoluteMax,
      length: samples,
      sampleRate: audioBuffer.sampleRate / sampleSize * 2
    };
  }
  decodeAudioData(buffer) {
    return new Promise((resolve, reject) => this.context.decodeAudioData(buffer, resolve, reject));
  }
};

// node_modules/@motion-canvas/core/lib/scenes/timeEvents/EditableTimeEvents.js
var EditableTimeEvents = class {
  get onChanged() {
    return this.events.subscribable;
  }
  constructor(scene) {
    this.scene = scene;
    this.events = new ValueDispatcher([]);
    this.registeredEvents = {};
    this.lookup = {};
    this.collisionLookup = /* @__PURE__ */ new Set();
    this.previousReference = [];
    this.didEventsChange = false;
    this.preserveTiming = true;
    this.handleReload = () => {
      this.registeredEvents = {};
      this.collisionLookup.clear();
    };
    this.handleRecalculated = () => {
      var _a;
      this.preserveTiming = true;
      this.events.current = Object.values(this.registeredEvents);
      if (this.didEventsChange || (((_a = this.previousReference) == null ? void 0 : _a.length) ?? 0) !== this.events.current.length) {
        this.didEventsChange = false;
        this.previousReference = Object.values(this.registeredEvents).map((event) => ({
          name: event.name,
          targetTime: event.targetTime
        }));
        this.scene.meta.timeEvents.set(this.previousReference);
      }
    };
    this.handleReset = () => {
      this.collisionLookup.clear();
    };
    this.handleMetaChanged = (data) => {
      if (data === this.previousReference)
        return;
      this.previousReference = data;
      this.load(data);
      this.scene.reload();
    };
    this.previousReference = scene.meta.timeEvents.get();
    this.load(this.previousReference);
    scene.onReloaded.subscribe(this.handleReload);
    scene.onRecalculated.subscribe(this.handleRecalculated);
    scene.onReset.subscribe(this.handleReset);
    scene.meta.timeEvents.onChanged.subscribe(this.handleMetaChanged, false);
  }
  set(name, offset, preserve = true) {
    if (!this.lookup[name] || this.lookup[name].offset === offset) {
      return;
    }
    this.preserveTiming = preserve;
    this.lookup[name] = {
      ...this.lookup[name],
      targetTime: this.lookup[name].initialTime + offset,
      offset
    };
    this.registeredEvents[name] = this.lookup[name];
    this.events.current = Object.values(this.registeredEvents);
    this.didEventsChange = true;
    this.scene.reload();
  }
  register(name, initialTime) {
    if (this.collisionLookup.has(name)) {
      this.scene.logger.error({
        message: `name "${name}" has already been used for another event name.`,
        stack: new Error().stack
      });
      return 0;
    }
    this.collisionLookup.add(name);
    if (!this.lookup[name]) {
      this.didEventsChange = true;
      this.lookup[name] = {
        name,
        initialTime,
        targetTime: initialTime,
        offset: 0,
        stack: new Error().stack
      };
    } else {
      let changed = false;
      const event = { ...this.lookup[name] };
      const stack = new Error().stack;
      if (event.stack !== stack) {
        event.stack = stack;
        changed = true;
      }
      if (event.initialTime !== initialTime) {
        event.initialTime = initialTime;
        changed = true;
      }
      const offset = Math.max(0, event.targetTime - event.initialTime);
      if (this.preserveTiming && event.offset !== offset) {
        event.offset = offset;
        changed = true;
      }
      const target = event.initialTime + event.offset;
      if (!this.preserveTiming && event.targetTime !== target) {
        this.didEventsChange = true;
        event.targetTime = target;
        changed = true;
      }
      if (changed) {
        this.lookup[name] = event;
      }
    }
    this.registeredEvents[name] = this.lookup[name];
    return this.lookup[name].offset;
  }
  load(events) {
    for (const event of events) {
      const previous = this.lookup[event.name] ?? {
        name: event.name,
        initialTime: 0,
        offset: 0
      };
      this.lookup[event.name] = {
        ...previous,
        targetTime: event.targetTime
      };
    }
  }
};

// node_modules/@motion-canvas/core/lib/scenes/timeEvents/ReadOnlyTimeEvents.js
var ReadOnlyTimeEvents = class {
  get onChanged() {
    return this.events.subscribable;
  }
  constructor(scene) {
    this.scene = scene;
    this.events = new ValueDispatcher([]);
    this.lookup = /* @__PURE__ */ new Map();
    this.handleReload = () => {
      this.lookup.clear();
    };
    scene.onReloaded.subscribe(this.handleReload);
  }
  set() {
  }
  register(name, initialTime) {
    let duration = this.lookup.get(name);
    if (duration === void 0) {
      const event = this.scene.meta.timeEvents.get().find((event2) => event2.name === name);
      duration = event ? event.targetTime - initialTime : 0;
      this.lookup.set(name, duration);
    }
    return duration;
  }
};

// node_modules/@motion-canvas/core/lib/app/Player.js
var MAX_AUDIO_DESYNC = 1 / 50;
var Player = class {
  /**
   * Triggered during each iteration of the update loop when the frame is ready
   * to be rendered.
   *
   * @remarks
   * Player does not perform any rendering on its own. For the animation to be
   * visible, another class must subscribe to this event and perform the
   * rendering itself. {@link Stage} can be used to display the animation.
   *
   * @eventProperty
   */
  get onRender() {
    return this.render.subscribable;
  }
  get onStateChanged() {
    return this.playerState.subscribable;
  }
  get onFrameChanged() {
    return this.frame.subscribable;
  }
  get onDurationChanged() {
    return this.duration.subscribable;
  }
  /**
   * Triggered right after recalculation finishes.
   *
   * @remarks
   * Can be used to provide visual feedback.
   *
   * @eventProperty
   */
  get onRecalculated() {
    return this.recalculated.subscribable;
  }
  get startFrame() {
    return Math.min(this.playback.duration, this.status.secondsToFrames(this.startTime));
  }
  get endFrame() {
    return Math.min(this.playback.duration, this.status.secondsToFrames(this.endTime));
  }
  get finished() {
    return this.playback.finished || this.playback.frame >= this.endFrame;
  }
  constructor(project, settings = {}, initialState = {}, initialFrame = -1) {
    var _a, _b, _c;
    this.project = project;
    this.settings = settings;
    this.initialState = initialState;
    this.initialFrame = initialFrame;
    this.render = new AsyncEventDispatcher();
    this.frame = new ValueDispatcher(0);
    this.duration = new ValueDispatcher(0);
    this.recalculated = new EventDispatcher();
    this.lock = new Semaphore();
    this.startTime = 0;
    this.endTime = Infinity;
    this.requestId = null;
    this.renderTime = 0;
    this.requestedSeek = -1;
    this.requestedRecalculation = true;
    this.active = false;
    this.playerState = new ValueDispatcher({
      loop: true,
      muted: true,
      speed: 1,
      ...initialState,
      paused: true
    });
    this.requestedSeek = initialFrame;
    this.logger = this.project.logger;
    this.playback = new PlaybackManager();
    this.status = new PlaybackStatus(this.playback);
    this.audio = new AudioManager(this.logger);
    this.size = settings.size ?? new Vector2(1920, 1080);
    this.resolutionScale = settings.resolutionScale ?? 1;
    this.startTime = ((_a = settings.range) == null ? void 0 : _a[0]) ?? 0;
    this.endTime = ((_b = settings.range) == null ? void 0 : _b[1]) ?? Infinity;
    this.playback.fps = settings.fps ?? 60;
    this.audio.setOffset(settings.audioOffset ?? 0);
    if (project.audio) {
      this.audio.setSource(project.audio);
    }
    const scenes = [];
    for (const description of project.scenes) {
      const scene = new description.klass({
        ...description,
        playback: this.status,
        logger: this.project.logger,
        size: this.size,
        resolutionScale: this.resolutionScale,
        timeEventsClass: EditableTimeEvents
      });
      (_c = description.onReplaced) == null ? void 0 : _c.subscribe((description2) => {
        scene.reload(description2);
      }, false);
      scene.onReloaded.subscribe(() => this.requestRecalculation());
      scene.variables.updateSignals(project.variables ?? {});
      scenes.push(scene);
    }
    this.playback.setup(scenes);
    this.activate();
  }
  async configure(settings) {
    await this.lock.acquire();
    let frame = this.playback.frame;
    let recalculate = false;
    this.startTime = settings.range[0];
    this.endTime = settings.range[1];
    if (this.playback.fps !== settings.fps) {
      const ratio = settings.fps / this.playback.fps;
      this.playback.fps = settings.fps;
      frame = Math.floor(frame * ratio);
      recalculate = true;
    }
    if (!settings.size.exactlyEquals(this.size) || settings.resolutionScale !== this.resolutionScale) {
      this.size = settings.size;
      this.resolutionScale = settings.resolutionScale;
      this.playback.reload({
        size: this.size,
        resolutionScale: this.resolutionScale
      });
    }
    if (settings.audioOffset !== void 0) {
      this.audio.setOffset(settings.audioOffset);
    }
    this.lock.release();
    if (recalculate) {
      this.playback.reload();
      this.frame.current = frame;
      this.requestRecalculation();
      this.requestedSeek = frame;
    }
  }
  requestSeek(value) {
    this.requestedSeek = this.clampRange(value);
  }
  requestPreviousFrame() {
    this.requestedSeek = this.frame.current - this.playback.speed;
  }
  requestNextFrame() {
    this.requestedSeek = this.frame.current + this.playback.speed;
  }
  requestReset() {
    this.requestedSeek = 0;
  }
  toggleLoop(value = !this.playerState.current.loop) {
    if (value !== this.playerState.current.loop) {
      this.playerState.current = {
        ...this.playerState.current,
        loop: value
      };
    }
  }
  togglePlayback(value = this.playerState.current.paused) {
    if (value === this.playerState.current.paused) {
      this.playerState.current = {
        ...this.playerState.current,
        paused: !value
      };
      if (value && !this.playerState.current.loop && this.playback.frame === this.playback.duration) {
        this.requestReset();
      }
    }
  }
  toggleAudio(value = this.playerState.current.muted) {
    if (value === this.playerState.current.muted) {
      this.playerState.current = {
        ...this.playerState.current,
        muted: !value
      };
    }
  }
  setSpeed(value) {
    if (value !== this.playerState.current.speed) {
      this.playback.speed = value;
      this.playback.reload();
      this.playerState.current = {
        ...this.playerState.current,
        speed: value
      };
      this.requestRecalculation();
    }
  }
  setVariables(variables) {
    for (const scene of this.playback.onScenesRecalculated.current) {
      scene.variables.updateSignals(variables);
    }
  }
  /**
   * Activate the player.
   *
   * @remarks
   * A player needs to be active in order for the update loop to run. Each
   * player is active by default.
   */
  activate() {
    this.active = true;
    this.request();
  }
  /**
   * Deactivate the player.
   *
   * @remarks
   * Deactivating the player prevents its update loop from running. This should
   * be done before disposing the player, to prevent it from running in the
   * background.
   *
   * Just pausing the player does not stop the loop.
   */
  deactivate() {
    this.active = false;
    if (this.requestId !== null) {
      cancelAnimationFrame(this.requestId);
      this.requestId = null;
    }
  }
  requestRecalculation() {
    this.requestedRecalculation = true;
    this.request();
  }
  async prepare() {
    const state = {
      ...this.playerState.current,
      seek: this.requestedSeek
    };
    this.requestedSeek = -1;
    if (this.requestedRecalculation) {
      if (state.seek < 0) {
        state.seek = this.playback.frame;
      }
      try {
        await this.playback.recalculate();
        this.duration.current = this.playback.frame;
        this.recalculated.dispatch();
      } catch (e) {
        this.requestSeek(state.seek);
        throw e;
      } finally {
        this.requestedRecalculation = false;
      }
    }
    if (!state.loop && this.finished && !state.paused && state.seek < 0 || this.endFrame === this.startFrame) {
      this.togglePlayback(false);
      state.paused = true;
    }
    if (state.loop && (state.seek > this.endFrame || this.finished && !state.paused) && this.startFrame !== this.endTime) {
      state.seek = this.startFrame;
    }
    const audioPaused = state.paused || this.finished || !this.audio.isInRange(this.status.time);
    if (await this.audio.setPaused(audioPaused)) {
      this.syncAudio(-3);
    }
    this.audio.setMuted(state.muted);
    return state;
  }
  async run() {
    const state = await this.prepare();
    const previousState = this.playback.state;
    this.playback.state = state.paused ? PlaybackState.Paused : PlaybackState.Playing;
    if (state.seek >= 0 || !this.isInRange(this.status.frame)) {
      const seekFrame = state.seek < 0 ? this.status.frame : state.seek;
      const clampedFrame = this.clampRange(seekFrame);
      this.logger.profile("seek time");
      await this.playback.seek(clampedFrame);
      this.logger.profile("seek time");
      this.syncAudio(-3);
    } else if (state.paused || state.speed === 1 && this.audio.isReady() && this.audio.isInRange(this.status.time) && this.audio.getTime() < this.status.time) {
      if (state.paused && previousState !== PlaybackState.Paused) {
        await this.render.dispatch();
      }
      if (!state.paused && this.status.time > this.audio.getTime() + MAX_AUDIO_DESYNC) {
        this.syncAudio();
      }
      this.request();
      return;
    } else if (this.audio.isReady() && state.speed === 1 && this.audio.isInRange(this.status.time) && this.status.framesToSeconds(this.playback.frame + 1) < this.audio.getTime() - MAX_AUDIO_DESYNC) {
      const seekFrame = this.status.secondsToFrames(this.audio.getTime());
      await this.playback.seek(seekFrame);
    } else if (this.status.frame < this.endFrame) {
      await this.playback.progress();
      if (state.speed !== 1) {
        this.syncAudio();
      }
    }
    if (!state.paused && this.playback.currentScene.slides.isWaiting()) {
      this.togglePlayback(false);
      state.paused = true;
    }
    await this.render.dispatch();
    this.frame.current = this.playback.frame;
    this.request();
  }
  request() {
    if (!this.active)
      return;
    this.requestId ?? (this.requestId = requestAnimationFrame(async (time) => {
      this.requestId = null;
      if (time - this.renderTime >= 1e3 / (this.status.fps + 5)) {
        this.renderTime = time;
        await this.lock.acquire();
        try {
          await this.run();
        } catch (e) {
          this.logger.error(e);
        }
        this.lock.release();
      } else {
        this.request();
      }
    }));
  }
  clampRange(frame) {
    return clamp(this.startFrame, this.endFrame, frame);
  }
  isInRange(frame) {
    return frame >= this.startFrame && frame <= this.endFrame;
  }
  syncAudio(frameOffset = 0) {
    this.audio.setTime(this.status.framesToSeconds(this.playback.frame + frameOffset));
  }
};

// node_modules/@motion-canvas/core/lib/app/Stage.js
var Stage = class {
  get canvasSize() {
    return this.size.scale(this.resolutionScale);
  }
  constructor() {
    this.background = null;
    this.resolutionScale = 1;
    this.colorSpace = "srgb";
    this.size = Vector2.zero;
    this.finalBuffer = document.createElement("canvas");
    this.currentBuffer = document.createElement("canvas");
    this.previousBuffer = document.createElement("canvas");
    const colorSpace = this.colorSpace;
    this.context = getContext({ colorSpace }, this.finalBuffer);
    this.currentContext = getContext({ colorSpace }, this.currentBuffer);
    this.previousContext = getContext({ colorSpace }, this.previousBuffer);
  }
  configure({ colorSpace = this.colorSpace, size = this.size, resolutionScale = this.resolutionScale, background = this.background }) {
    if (colorSpace !== this.colorSpace) {
      this.colorSpace = colorSpace;
      this.context = getContext({ colorSpace }, this.finalBuffer);
      this.currentContext = getContext({ colorSpace }, this.currentBuffer);
      this.previousContext = getContext({ colorSpace }, this.previousBuffer);
    }
    if (!size.exactlyEquals(this.size) || resolutionScale !== this.resolutionScale) {
      this.resolutionScale = resolutionScale;
      this.size = size;
      this.resizeCanvas(this.context);
      this.resizeCanvas(this.currentContext);
      this.resizeCanvas(this.previousContext);
    }
    this.background = typeof background === "string" ? background : (background == null ? void 0 : background.serialize()) ?? null;
  }
  async render(currentScene, previousScene) {
    if (previousScene) {
      this.transformCanvas(this.previousContext);
      await previousScene.render(this.previousContext);
    }
    this.transformCanvas(this.currentContext);
    await currentScene.render(this.currentContext);
    const size = this.canvasSize;
    this.context.clearRect(0, 0, size.width, size.height);
    if (this.background) {
      this.context.save();
      this.context.fillStyle = this.background;
      this.context.fillRect(0, 0, size.width, size.height);
      this.context.restore();
    }
    if (previousScene) {
      this.context.drawImage(this.previousBuffer, 0, 0);
    }
    this.context.drawImage(this.currentBuffer, 0, 0);
  }
  transformCanvas(context) {
    const offset = this.canvasSize.scale(0.5);
    context.setTransform(this.resolutionScale, 0, 0, this.resolutionScale, offset.x, offset.y);
  }
  resizeCanvas(context) {
    const size = this.canvasSize;
    context.canvas.width = size.width;
    context.canvas.height = size.height;
  }
};

// node_modules/@motion-canvas/core/lib/app/Presenter.js
var PresenterState;
(function(PresenterState2) {
  PresenterState2[PresenterState2["Initial"] = 0] = "Initial";
  PresenterState2[PresenterState2["Working"] = 1] = "Working";
  PresenterState2[PresenterState2["Aborting"] = 2] = "Aborting";
})(PresenterState || (PresenterState = {}));
var NextSlide = Symbol("@motion-canvas/core/app/NextSlide");
var PreviousSlide = Symbol("@motion-canvas/core/app/PreviousSlide");
var Presenter = class {
  get onStateChanged() {
    return this.state.subscribable;
  }
  get onInfoChanged() {
    return this.info.subscribable;
  }
  get onSlidesChanged() {
    return this.slides.subscribable;
  }
  constructor(project) {
    this.project = project;
    this.state = new ValueDispatcher(PresenterState.Initial);
    this.info = new ValueDispatcher({
      currentSlideId: null,
      nextSlideId: null,
      hasNext: false,
      hasPrevious: false,
      isWaiting: false,
      index: null,
      count: 0
    });
    this.slides = new ValueDispatcher([]);
    this.stage = new Stage();
    this.lock = new Semaphore();
    this.abortController = null;
    this.renderTime = 0;
    this.requestId = null;
    this.requestedResume = false;
    this.requestedSlide = null;
    this.logger = project.logger;
    this.playback = new PlaybackManager();
    this.status = new PlaybackStatus(this.playback);
    const scenes = [];
    for (const description of project.scenes) {
      const scene = new description.klass({
        ...description,
        meta: description.meta.clone(),
        logger: this.logger,
        playback: this.status,
        size: new Vector2(1920, 1080),
        resolutionScale: 1,
        timeEventsClass: ReadOnlyTimeEvents
      });
      scenes.push(scene);
    }
    this.playback.setup(scenes);
  }
  /**
   * Present the animation.
   *
   * @param settings - The presentation settings.
   */
  async present(settings) {
    if (this.state.current !== PresenterState.Initial)
      return;
    await this.lock.acquire();
    this.state.current = PresenterState.Working;
    try {
      this.abortController = new AbortController();
      await this.run(settings, this.abortController.signal);
    } catch (e) {
      this.project.logger.error(e);
    }
    this.state.current = PresenterState.Initial;
    this.lock.release();
  }
  /**
   * Abort the ongoing presentation process.
   */
  abort() {
    var _a;
    if (this.state.current === PresenterState.Initial)
      return;
    (_a = this.abortController) == null ? void 0 : _a.abort();
    this.state.current = PresenterState.Aborting;
  }
  /**
   * Resume the presentation if waiting for the next slide.
   */
  resume() {
    this.requestedResume = true;
  }
  requestFirstSlide() {
    const first = this.playback.slides[0];
    if (first) {
      this.requestedSlide = first.id;
    }
  }
  requestLastSlide() {
    const last = this.playback.slides.at(-1);
    if (last) {
      this.requestedSlide = last.id;
    }
  }
  requestPreviousSlide() {
    this.requestedSlide = PreviousSlide;
  }
  requestNextSlide() {
    this.requestedSlide = NextSlide;
  }
  requestSlide(id) {
    this.requestedSlide = id;
  }
  async run(settings, signal) {
    this.stage.configure(settings);
    this.playback.fps = settings.fps;
    await this.reloadScenes(settings);
    if (signal.aborted)
      return;
    this.playback.state = PlaybackState.Playing;
    await this.playback.recalculate();
    if (signal.aborted)
      return;
    this.slides.current = this.playback.slides;
    this.playback.state = PlaybackState.Presenting;
    await this.playback.reset();
    if (signal.aborted)
      return;
    if (settings.slide) {
      await this.playback.goTo(settings.slide);
      if (signal.aborted)
        return;
    }
    await new Promise((resolve) => {
      signal.addEventListener("abort", resolve);
      this.request();
    });
  }
  async reloadScenes(settings) {
    for (let i = 0; i < this.project.scenes.length; i++) {
      const description = this.project.scenes[i];
      const scene = this.playback.onScenesRecalculated.current[i];
      scene.reload({
        config: description.onReplaced.current.config,
        size: settings.size,
        resolutionScale: settings.resolutionScale
      });
      scene.meta.set(description.meta.get());
    }
  }
  async loop() {
    var _a;
    const slide = this.requestedSlide;
    const resume = this.requestedResume;
    this.requestedResume = false;
    this.requestedSlide = null;
    if (resume) {
      this.playback.currentScene.slides.resume();
    }
    if (slide !== null) {
      this.logger.profile("slide time");
      this.playback.state = PlaybackState.Playing;
      if (slide === PreviousSlide) {
        await this.playback.goBack();
      } else if (slide === NextSlide) {
        await this.playback.goForward();
      } else {
        await this.playback.goTo(slide);
      }
      this.logger.profile("slide time");
    } else if (!this.playback.finished) {
      this.playback.state = PlaybackState.Presenting;
      await this.playback.progress();
    }
    await this.stage.render(this.playback.currentScene, this.playback.previousScene);
    if (!((_a = this.abortController) == null ? void 0 : _a.signal.aborted)) {
      this.updateInfo();
      this.request();
    }
  }
  request() {
    var _a;
    if ((_a = this.abortController) == null ? void 0 : _a.signal.aborted) {
      return;
    }
    this.requestId ?? (this.requestId = requestAnimationFrame(async (time) => {
      var _a2;
      this.requestId = null;
      if (time - this.renderTime >= 1e3 / (this.status.fps + 5)) {
        this.renderTime = time;
        try {
          await this.loop();
        } catch (e) {
          this.logger.error(e);
          (_a2 = this.abortController) == null ? void 0 : _a2.abort();
        }
      } else {
        this.request();
      }
    }));
  }
  updateInfo() {
    var _a;
    const slides = this.playback.currentScene.slides;
    const currentSlide = slides.getCurrent() ?? null;
    const index = this.playback.slides.indexOf(currentSlide);
    const info = {
      currentSlideId: (currentSlide == null ? void 0 : currentSlide.id) ?? null,
      nextSlideId: ((_a = this.playback.slides[index + 1]) == null ? void 0 : _a.id) ?? null,
      hasNext: index !== null && index < this.playback.slides.length - 1,
      hasPrevious: index !== null && index > 0,
      isWaiting: slides.isWaiting(),
      count: this.playback.slides.length,
      index
    };
    for (const [key, value] of Object.entries(info)) {
      if (this.info.current[key] !== value) {
        this.info.current = info;
        break;
      }
    }
  }
};

// node_modules/@motion-canvas/core/lib/app/Project.js
function makeProject(settings) {
  return {
    logger: new Logger(),
    plugins: [],
    ...settings
  };
}

// node_modules/@motion-canvas/core/lib/app/ProjectMetadata.js
function createProjectMetadata(project) {
  const meta = {
    version: new MetaField("version", 1),
    shared: new ObjectMetaField("General", {
      background: new ColorMetaField("background", null),
      range: new RangeMetaField("range", [0, Infinity]),
      size: new Vector2MetaField("resolution", new Vector2(1920, 1080)),
      audioOffset: new NumberMetaField("audio offset", 0)
    }),
    preview: new ObjectMetaField("Preview", {
      fps: new NumberMetaField("frame rate", 30).setPresets(FrameRates),
      resolutionScale: new EnumMetaField("scale", Scales, 1)
    }),
    rendering: new ObjectMetaField("Rendering", {
      fps: new NumberMetaField("frame rate", 60).setPresets(FrameRates),
      resolutionScale: new EnumMetaField("scale", Scales, 1),
      colorSpace: new EnumMetaField("color space", ColorSpaces),
      exporter: new ExporterMetaField("exporter", project.plugins.flatMap((plugin) => {
        var _a;
        return ((_a = plugin.exporters) == null ? void 0 : _a.call(plugin, project)) ?? [];
      }))
    })
  };
  meta.shared.audioOffset.disable(!project.audio);
  return meta;
}
var ProjectMetadata = class extends ObjectMetaField {
  constructor(project) {
    super("project", createProjectMetadata(project));
  }
  getFullPreviewSettings() {
    return {
      ...this.shared.get(),
      ...this.preview.get()
    };
  }
  getFullRenderingSettings() {
    return {
      ...this.shared.get(),
      ...this.rendering.get()
    };
  }
};

// node_modules/@motion-canvas/core/lib/app/Renderer.js
var RendererState;
(function(RendererState2) {
  RendererState2[RendererState2["Initial"] = 0] = "Initial";
  RendererState2[RendererState2["Working"] = 1] = "Working";
  RendererState2[RendererState2["Aborting"] = 2] = "Aborting";
})(RendererState || (RendererState = {}));
var RendererResult;
(function(RendererResult2) {
  RendererResult2[RendererResult2["Success"] = 0] = "Success";
  RendererResult2[RendererResult2["Error"] = 1] = "Error";
  RendererResult2[RendererResult2["Aborted"] = 2] = "Aborted";
})(RendererResult || (RendererResult = {}));
var Renderer = class {
  get onStateChanged() {
    return this.state.subscribable;
  }
  get onFinished() {
    return this.finished.subscribable;
  }
  get onFrameChanged() {
    return this.frame.subscribable;
  }
  constructor(project) {
    this.project = project;
    this.state = new ValueDispatcher(RendererState.Initial);
    this.finished = new EventDispatcher();
    this.frame = new ValueDispatcher(0);
    this.stage = new Stage();
    this.lock = new Semaphore();
    this.exporter = new ImageExporter(this.project.logger);
    this.abortController = null;
    this.playback = new PlaybackManager();
    this.status = new PlaybackStatus(this.playback);
    const scenes = [];
    for (const description of project.scenes) {
      const scene = new description.klass({
        ...description,
        meta: description.meta.clone(),
        logger: this.project.logger,
        playback: this.status,
        size: new Vector2(1920, 1080),
        resolutionScale: 1,
        timeEventsClass: ReadOnlyTimeEvents
      });
      scenes.push(scene);
    }
    this.playback.setup(scenes);
  }
  /**
   * Render the animation using the provided settings.
   *
   * @param settings - The rendering settings.
   */
  async render(settings) {
    if (this.state.current !== RendererState.Initial)
      return;
    await this.lock.acquire();
    this.state.current = RendererState.Working;
    let result;
    try {
      this.abortController = new AbortController();
      result = await this.run(settings, this.abortController.signal);
    } catch (e) {
      this.project.logger.error(e);
      result = RendererResult.Error;
    }
    this.state.current = RendererState.Initial;
    this.finished.dispatch(result);
    this.lock.release();
  }
  /**
   * Abort the ongoing render process.
   */
  abort() {
    var _a;
    if (this.state.current !== RendererState.Working)
      return;
    (_a = this.abortController) == null ? void 0 : _a.abort();
    this.state.current = RendererState.Aborting;
  }
  /**
   * Export an individual frame.
   *
   * @remarks
   * This method always uses the default {@link ImageExporter}.
   *
   * @param settings - The rendering settings.
   * @param frame - The frame to export.
   */
  async renderFrame(settings, frame) {
    await this.lock.acquire();
    try {
      this.stage.configure(settings);
      this.playback.fps = settings.fps;
      this.playback.state = PlaybackState.Rendering;
      await this.reloadScenes(settings);
      await this.playback.reset();
      await this.playback.seek(this.status.secondsToFrames(settings.range[0]));
      await this.stage.render(this.playback.currentScene, this.playback.previousScene);
      if (import.meta.hot) {
        import.meta.hot.send("motion-canvas:export", {
          frame,
          data: this.stage.finalBuffer.toDataURL("image/png"),
          mimeType: "image/png",
          subDirectories: ["still", this.project.name]
        });
      }
    } catch (e) {
      this.project.logger.error(e);
    }
    this.lock.release();
  }
  async run(settings, signal) {
    settings = await this.exporter.configure(settings) ?? settings;
    this.stage.configure(settings);
    this.playback.fps = settings.fps;
    this.playback.state = PlaybackState.Rendering;
    const from = this.status.secondsToFrames(settings.range[0]);
    const to = this.status.secondsToFrames(settings.range[1]);
    await this.reloadScenes(settings);
    await this.playback.recalculate();
    if (signal.aborted)
      return RendererResult.Aborted;
    await this.playback.reset();
    if (signal.aborted)
      return RendererResult.Aborted;
    await this.playback.seek(from);
    if (signal.aborted)
      return RendererResult.Aborted;
    await this.exporter.start();
    let lastRefresh = performance.now();
    let result = RendererResult.Success;
    try {
      await this.exportFrame(signal);
      if (signal.aborted) {
        result = RendererResult.Aborted;
      } else {
        let finished = false;
        while (!finished) {
          await this.playback.progress();
          await this.exportFrame(signal);
          if (performance.now() - lastRefresh > 1 / 30) {
            lastRefresh = performance.now();
            await new Promise((resolve) => setTimeout(resolve, 0));
          }
          if (this.playback.finished || this.playback.frame >= to) {
            finished = true;
          }
          if (signal.aborted) {
            result = RendererResult.Aborted;
            finished = true;
          }
        }
      }
    } catch (e) {
      this.project.logger.error(e);
      result = RendererResult.Error;
    }
    await this.exporter.stop(result);
    return result;
  }
  async reloadScenes(settings) {
    for (let i = 0; i < this.project.scenes.length; i++) {
      const description = this.project.scenes[i];
      const scene = this.playback.onScenesRecalculated.current[i];
      scene.reload({
        config: description.onReplaced.current.config,
        size: settings.size,
        resolutionScale: settings.resolutionScale
      });
      scene.meta.set(description.meta.get());
    }
  }
  async exportFrame(signal) {
    this.frame.current = this.playback.frame;
    await this.stage.render(this.playback.currentScene, this.playback.previousScene);
    const sceneFrame = this.playback.frame - this.playback.currentScene.firstFrame;
    await this.exporter.handleFrame(this.stage.finalBuffer, this.playback.frame, sceneFrame, this.playback.currentScene.name, signal);
  }
};

export {
  ImageExporter,
  LogLevel,
  Logger,
  PlaybackStatus,
  Player,
  Stage,
  PresenterState,
  Presenter,
  makeProject,
  ProjectMetadata,
  RendererState,
  RendererResult,
  Renderer
};
//# sourceMappingURL=chunk-Z3IH7QWM.js.map
