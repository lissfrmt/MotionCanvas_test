import {
  Shape,
  drawImage,
  drawRoundRect,
  spacingSignal
} from "./chunk-B6CO33KU.js";
import {
  computed,
  initial,
  signal
} from "./chunk-TXLKDWQ4.js";
import {
  BBox,
  DependencyContext,
  Vector2,
  import_chroma_js,
  viaProxy
} from "./chunk-ZOQDAVQN.js";

// node_modules/@motion-canvas/2d/lib/components/Rect.js
var __decorate = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var Rect = class extends Shape {
  constructor(props) {
    super(props);
  }
  getPath() {
    const path = new Path2D();
    const radius = this.radius();
    const smoothCorners = this.smoothCorners();
    const cornerSharpness = this.cornerSharpness();
    const box = BBox.fromSizeCentered(this.size());
    drawRoundRect(path, box, radius, smoothCorners, cornerSharpness);
    return path;
  }
  getCacheBBox() {
    return super.getCacheBBox().expand(this.rippleSize());
  }
  getRipplePath() {
    const path = new Path2D();
    const rippleSize = this.rippleSize();
    const radius = this.radius().addScalar(rippleSize);
    const smoothCorners = this.smoothCorners();
    const cornerSharpness = this.cornerSharpness();
    const box = BBox.fromSizeCentered(this.size()).expand(rippleSize);
    drawRoundRect(path, box, radius, smoothCorners, cornerSharpness);
    return path;
  }
};
__decorate([
  spacingSignal("radius")
], Rect.prototype, "radius", void 0);
__decorate([
  initial(false),
  signal()
], Rect.prototype, "smoothCorners", void 0);
__decorate([
  initial(0.6),
  signal()
], Rect.prototype, "cornerSharpness", void 0);

// node_modules/@motion-canvas/2d/lib/components/Img.js
var __decorate2 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var Img = class extends Rect {
  constructor(props) {
    super(props);
  }
  desiredSize() {
    const custom = super.desiredSize();
    if (custom.x === null && custom.y === null) {
      const image = this.image();
      return {
        x: image.naturalWidth,
        y: image.naturalHeight
      };
    }
    return custom;
  }
  image() {
    const src = viaProxy(this.src());
    let image = Img.pool[src];
    if (!image) {
      image = document.createElement("img");
      image.crossOrigin = "anonymous";
      image.src = src;
      Img.pool[src] = image;
    }
    if (!image.complete) {
      DependencyContext.collectPromise(new Promise((resolve, reject) => {
        image.addEventListener("load", resolve);
        image.addEventListener("error", reject);
      }));
    }
    return image;
  }
  imageCanvas() {
    const canvas = document.createElement("canvas").getContext("2d", { willReadFrequently: true });
    if (!canvas) {
      throw new Error("Could not create an image canvas");
    }
    return canvas;
  }
  filledImageCanvas() {
    const context = this.imageCanvas();
    const image = this.image();
    context.canvas.width = image.naturalWidth;
    context.canvas.height = image.naturalHeight;
    context.imageSmoothingEnabled = this.smoothing();
    context.drawImage(image, 0, 0);
    return context;
  }
  draw(context) {
    this.drawShape(context);
    if (this.clip()) {
      context.clip(this.getPath());
    }
    const alpha = this.alpha();
    if (alpha > 0) {
      const box = BBox.fromSizeCentered(this.computedSize());
      context.save();
      if (alpha < 1) {
        context.globalAlpha *= alpha;
      }
      context.imageSmoothingEnabled = this.smoothing();
      drawImage(context, this.image(), box);
      context.restore();
    }
    this.drawChildren(context);
  }
  applyFlex() {
    super.applyFlex();
    const image = this.image();
    this.element.style.aspectRatio = (this.ratio() ?? image.naturalWidth / image.naturalHeight).toString();
  }
  /**
   * Get color of the image at the given position.
   *
   * @param position - The position in local space at which to sample the color.
   */
  getColorAtPoint(position) {
    const size = this.computedSize();
    const naturalSize = this.naturalSize();
    const pixelPosition = new Vector2(position).add(this.computedSize().scale(0.5)).mul(naturalSize.div(size).safe);
    return this.getPixelColor(pixelPosition);
  }
  /**
   * The natural size of this image.
   *
   * @remarks
   * The natural size is the size of the source image unaffected by the size
   * and scale properties.
   */
  naturalSize() {
    const image = this.image();
    return new Vector2(image.naturalWidth, image.naturalHeight);
  }
  /**
   * Get color of the image at the given pixel.
   *
   * @param position - The pixel's position.
   */
  getPixelColor(position) {
    const context = this.filledImageCanvas();
    const vector = new Vector2(position);
    const data = context.getImageData(vector.x, vector.y, 1, 1).data;
    return new import_chroma_js.Color({
      r: data[0],
      g: data[1],
      b: data[2],
      a: data[3] / 255
    });
  }
  collectAsyncResources() {
    super.collectAsyncResources();
    this.image();
  }
};
Img.pool = {};
__decorate2([
  signal()
], Img.prototype, "src", void 0);
__decorate2([
  initial(1),
  signal()
], Img.prototype, "alpha", void 0);
__decorate2([
  initial(true),
  signal()
], Img.prototype, "smoothing", void 0);
__decorate2([
  computed()
], Img.prototype, "image", null);
__decorate2([
  computed()
], Img.prototype, "imageCanvas", null);
__decorate2([
  computed()
], Img.prototype, "filledImageCanvas", null);
__decorate2([
  computed()
], Img.prototype, "naturalSize", null);

export {
  Rect,
  Img
};
//# sourceMappingURL=chunk-UTXL64G2.js.map
