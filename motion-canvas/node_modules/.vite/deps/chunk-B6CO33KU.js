import {
  FILTERS,
  Filter,
  Gradient,
  Pattern,
  addInitializer,
  cloneable,
  compound,
  computed,
  getPropertiesOf,
  getPropertyMetaOrCreate,
  initial,
  initializeSignals,
  inspectable,
  interpolation,
  parser,
  signal,
  vector2Signal,
  wrapper
} from "./chunk-TXLKDWQ4.js";
import {
  BBox,
  DependencyContext,
  DetailedError,
  Origin,
  SignalContext,
  Spacing,
  Vector2,
  all,
  capitalize,
  createSignal,
  deepLerp,
  easeInOutCubic,
  easeOutExpo,
  import_chroma_js,
  isReactive,
  linear,
  map,
  originToOffset,
  threadable,
  transformAngle,
  transformScalar,
  tween,
  useLogger,
  useScene
} from "./chunk-ZOQDAVQN.js";

// node_modules/@motion-canvas/2d/lib/utils/CanvasUtils.js
function canvasStyleParser(style) {
  if (style === null) {
    return null;
  }
  if (style instanceof Gradient) {
    return style;
  }
  if (style instanceof Pattern) {
    return style;
  }
  return new import_chroma_js.Color(style);
}
function resolveCanvasStyle(style, context) {
  if (style === null) {
    return "";
  }
  if (style instanceof import_chroma_js.Color) {
    return style.serialize();
  }
  if (style instanceof Gradient) {
    return style.canvasGradient(context);
  }
  if (style instanceof Pattern) {
    return style.canvasPattern(context) ?? "";
  }
  return "";
}
function drawRoundRect(context, rect, radius, smoothCorners, cornerSharpness) {
  if (radius.top === 0 && radius.right === 0 && radius.bottom === 0 && radius.left === 0) {
    drawRect(context, rect);
    return;
  }
  const topLeft = adjustRectRadius(radius.top, radius.right, radius.left, rect);
  const topRight = adjustRectRadius(radius.right, radius.top, radius.bottom, rect);
  const bottomRight = adjustRectRadius(radius.bottom, radius.left, radius.right, rect);
  const bottomLeft = adjustRectRadius(radius.left, radius.bottom, radius.top, rect);
  if (smoothCorners) {
    const sharpness = (radius2) => {
      const val = radius2 * cornerSharpness;
      return radius2 - val;
    };
    context.moveTo(rect.left + topLeft, rect.top);
    context.lineTo(rect.right - topRight, rect.top);
    context.bezierCurveTo(rect.right - sharpness(topRight), rect.top, rect.right, rect.top + sharpness(topRight), rect.right, rect.top + topRight);
    context.lineTo(rect.right, rect.bottom - bottomRight);
    context.bezierCurveTo(rect.right, rect.bottom - sharpness(bottomRight), rect.right - sharpness(bottomRight), rect.bottom, rect.right - bottomRight, rect.bottom);
    context.lineTo(rect.left + bottomLeft, rect.bottom);
    context.bezierCurveTo(rect.left + sharpness(bottomLeft), rect.bottom, rect.left, rect.bottom - sharpness(bottomLeft), rect.left, rect.bottom - bottomLeft);
    context.lineTo(rect.left, rect.top + topLeft);
    context.bezierCurveTo(rect.left, rect.top + sharpness(topLeft), rect.left + sharpness(topLeft), rect.top, rect.left + topLeft, rect.top);
    return;
  }
  context.moveTo(rect.left + topLeft, rect.top);
  context.arcTo(rect.right, rect.top, rect.right, rect.bottom, topRight);
  context.arcTo(rect.right, rect.bottom, rect.left, rect.bottom, bottomRight);
  context.arcTo(rect.left, rect.bottom, rect.left, rect.top, bottomLeft);
  context.arcTo(rect.left, rect.top, rect.right, rect.top, topLeft);
}
function adjustRectRadius(radius, horizontal, vertical, rect) {
  const width = radius + horizontal > rect.width ? rect.width * (radius / (radius + horizontal)) : radius;
  const height = radius + vertical > rect.height ? rect.height * (radius / (radius + vertical)) : radius;
  return Math.min(width, height);
}
function drawRect(context, rect) {
  context.rect(rect.x, rect.y, rect.width, rect.height);
}
function drawPolygon(path, rect, sides) {
  const size = rect.size.scale(0.5);
  for (let i = 0; i <= sides; i++) {
    const theta = i * 2 * Math.PI / sides;
    const direction = Vector2.fromRadians(theta).perpendicular;
    const vertex = direction.mul(size);
    if (i == 0) {
      moveTo(path, vertex);
    } else {
      lineTo(path, vertex);
    }
  }
  path.closePath();
}
function drawImage(context, image, first, second) {
  if (second) {
    context.drawImage(image, first.x, first.y, first.width, first.height, second.x, second.y, second.width, second.height);
  } else {
    context.drawImage(image, first.x, first.y, first.width, first.height);
  }
}
function moveTo(context, position) {
  context.moveTo(position.x, position.y);
}
function lineTo(context, position) {
  context.lineTo(position.x, position.y);
}
function drawLine(context, points) {
  if (points.length < 2)
    return;
  moveTo(context, points[0]);
  for (const point of points.slice(1)) {
    lineTo(context, point);
  }
}
function arc(context, center, radius, startAngle = 0, endAngle = Math.PI * 2, counterclockwise = false) {
  context.arc(center.x, center.y, radius, startAngle, endAngle, counterclockwise);
}
function bezierCurveTo(context, controlPoint1, controlPoint2, to) {
  context.bezierCurveTo(controlPoint1.x, controlPoint1.y, controlPoint2.x, controlPoint2.y, to.x, to.y);
}
function quadraticCurveTo(context, controlPoint, to) {
  context.quadraticCurveTo(controlPoint.x, controlPoint.y, to.x, to.y);
}

// node_modules/@motion-canvas/2d/lib/decorators/canvasStyleSignal.js
function canvasStyleSignal() {
  return (target, key) => {
    signal()(target, key);
    parser(canvasStyleParser)(target, key);
    interpolation(import_chroma_js.Color.lerp)(target, key);
    initial(null)(target, key);
  };
}

// node_modules/@motion-canvas/2d/lib/decorators/defaultStyle.js
function defaultStyle(styleName, parse = (value) => value) {
  return (target, key) => {
    target[`getDefault${capitalize(key)}`] = function() {
      this.requestLayoutUpdate();
      const old = this.element.style[styleName];
      this.element.style[styleName] = "";
      const ret = parse.call(this, this.styles.getPropertyValue(styleName));
      this.element.style[styleName] = old;
      return ret;
    };
  };
}

// node_modules/@motion-canvas/2d/lib/decorators/colorSignal.js
function colorSignal() {
  return (target, key) => {
    signal()(target, key);
    wrapper(import_chroma_js.Color)(target, key);
  };
}

// node_modules/@motion-canvas/2d/lib/decorators/filtersSignal.js
var FiltersSignalContext = class extends SignalContext {
  constructor(initial2, owner) {
    super(initial2, deepLerp, owner);
    for (const filter in FILTERS) {
      const props = FILTERS[filter];
      Object.defineProperty(this.invokable, filter, {
        value: (newValue, duration, timingFunction = easeInOutCubic) => {
          var _a, _b, _c;
          if (newValue === void 0) {
            return ((_b = (_a = this.get()) == null ? void 0 : _a.find((filter2) => filter2.name === props.name)) == null ? void 0 : _b.value()) ?? props.default ?? 0;
          }
          let instance = (_c = this.get()) == null ? void 0 : _c.find((filter2) => filter2.name === props.name);
          if (!instance) {
            instance = new Filter(props);
            this.set([...this.get(), instance]);
          }
          if (duration === void 0) {
            instance.value(newValue);
            return this.owner;
          }
          return instance.value(newValue, duration, timingFunction);
        }
      });
    }
  }
  *doTween(value, duration, timingFunction) {
    const from = this.get();
    const to = isReactive(value) ? value() : value;
    if (areFiltersCompatible(from, to)) {
      yield* all(...from.map((filter, i) => filter.value(to[i].value(), duration, timingFunction)));
      this.set(to);
      return;
    }
    for (const filter of to) {
      filter.value(filter.default);
    }
    const toValues = to.map((filter) => filter.value.context.raw());
    const partialDuration = from.length > 0 && to.length > 0 ? duration / 2 : duration;
    if (from.length > 0) {
      yield* all(...from.map((filter) => filter.value(filter.default, partialDuration, timingFunction)));
    }
    this.set(to);
    if (to.length > 0) {
      yield* all(...to.map((filter, index) => filter.value(toValues[index], partialDuration, timingFunction)));
    }
  }
};
function filtersSignal() {
  return (target, key) => {
    const meta = getPropertyMetaOrCreate(target, key);
    addInitializer(target, (instance) => {
      instance[key] = new FiltersSignalContext(meta.default ?? [], instance).toSignal();
    });
  };
}
function areFiltersCompatible(a, b) {
  if (a.length !== b.length)
    return false;
  for (let i = 0; i < a.length; i++) {
    if (a[i].name !== b[i].name) {
      return false;
    }
  }
  return true;
}

// node_modules/@motion-canvas/2d/lib/scenes/useScene2D.js
function useScene2D() {
  return useScene();
}

// node_modules/@motion-canvas/2d/lib/components/Node.js
var __decorate = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var Node = class {
  getAbsolutePosition() {
    const matrix = this.localToWorld();
    return new Vector2(matrix.m41, matrix.m42);
  }
  setAbsolutePosition(value) {
    if (isReactive(value)) {
      this.position(() => value().transformAsPoint(this.worldToParent()));
    } else {
      this.position(value.transformAsPoint(this.worldToParent()));
    }
  }
  getAbsoluteRotation() {
    const matrix = this.localToWorld();
    return Math.atan2(matrix.m12, matrix.m11) * 180 / Math.PI;
  }
  setAbsoluteRotation(value) {
    if (isReactive(value)) {
      this.rotation(() => transformAngle(value(), this.worldToParent()));
    } else {
      this.rotation(transformAngle(value, this.worldToParent()));
    }
  }
  getAbsoluteScale() {
    const matrix = this.localToWorld();
    return new Vector2(Vector2.magnitude(matrix.m11, matrix.m12), Vector2.magnitude(matrix.m21, matrix.m22));
  }
  setAbsoluteScale(value) {
    if (isReactive(value)) {
      this.scale(() => this.getRelativeScale(value()));
    } else {
      this.scale(this.getRelativeScale(value));
    }
  }
  getRelativeScale(scale) {
    var _a;
    const parentScale = ((_a = this.parent()) == null ? void 0 : _a.absoluteScale()) ?? Vector2.one;
    return scale.div(parentScale);
  }
  *tweenCompositeOperation(value, time, timingFunction) {
    const nextValue = isReactive(value) ? value() : value;
    if (nextValue === "source-over") {
      yield* this.compositeOverride(1, time, timingFunction);
      this.compositeOverride(0);
      this.compositeOperation(nextValue);
    } else {
      this.compositeOperation(nextValue);
      this.compositeOverride(1);
      yield* this.compositeOverride(0, time, timingFunction);
    }
  }
  absoluteOpacity() {
    var _a;
    return (((_a = this.parent()) == null ? void 0 : _a.absoluteOpacity()) ?? 1) * this.opacity();
  }
  hasFilters() {
    return !!this.filters().find((filter) => filter.isActive());
  }
  hasShadow() {
    return !!this.shadowColor() && (this.shadowBlur() > 0 || this.shadowOffset.x() !== 0 || this.shadowOffset.y() !== 0);
  }
  filterString() {
    let filters = "";
    const matrix = this.compositeToWorld();
    for (const filter of this.filters()) {
      if (filter.isActive()) {
        filters += " " + filter.serialize(matrix);
      }
    }
    return filters;
  }
  setChildren(value) {
    this.spawner(value);
  }
  getChildren() {
    this.spawnChildren();
    return this.realChildren;
  }
  spawnChildren() {
    const children = this.spawner();
    if (isReactive(this.spawner.context.raw())) {
      const keep = /* @__PURE__ */ new Set();
      for (const realChild of children) {
        const current = realChild.parent.context.raw();
        if (current && current !== this) {
          throw new DetailedError("The spawner returned a node that already has a parent", "A spawner should either create entirely new nodes or reuse nodes from a pool.");
        }
        realChild.parent(this);
        keep.add(realChild.key);
      }
      for (const realChild of this.realChildren) {
        if (!keep.has(realChild.key)) {
          realChild.parent(null);
        }
      }
      this.realChildren = children;
    } else {
      this.realChildren = children;
    }
  }
  sortedChildren() {
    return [...this.children()].sort((a, b) => Math.sign(a.zIndex() - b.zIndex()));
  }
  constructor({ children, spawner, key, ...rest }) {
    this.compositeOverride = createSignal(0);
    this.stateStack = [];
    this.realChildren = [];
    this.parent = createSignal(null);
    this.properties = getPropertiesOf(this);
    const scene = useScene2D();
    this.key = scene.registerNode(this, key);
    this.view2D = scene.getView();
    this.creationStack = new Error().stack;
    initializeSignals(this, rest);
    this.add(children);
    if (spawner) {
      this.children(spawner);
    }
  }
  /**
   * Get the local-to-world matrix for this node.
   *
   * @remarks
   * This matrix transforms vectors from local space of this node to world
   * space.
   *
   * @example
   * Calculate the absolute position of a point located 200 pixels to the right
   * of the node:
   * ```ts
   * const local = new Vector2(0, 200);
   * const world = local.transformAsPoint(node.localToWorld());
   * ```
   */
  localToWorld() {
    const parent = this.parent();
    return parent ? parent.localToWorld().multiply(this.localToParent()) : this.localToParent();
  }
  /**
   * Get the world-to-local matrix for this node.
   *
   * @remarks
   * This matrix transforms vectors from world space to local space of this
   * node.
   *
   * @example
   * Calculate the position relative to this node for a point located in the
   * top-left corner of the screen:
   * ```ts
   * const world = new Vector2(0, 0);
   * const local = world.transformAsPoint(node.worldToLocal());
   * ```
   */
  worldToLocal() {
    return this.localToWorld().inverse();
  }
  /**
   * Get the world-to-parent matrix for this node.
   *
   * @remarks
   * This matrix transforms vectors from world space to local space of this
   * node's parent.
   */
  worldToParent() {
    var _a;
    return ((_a = this.parent()) == null ? void 0 : _a.worldToLocal()) ?? new DOMMatrix();
  }
  /**
   * Get the local-to-parent matrix for this node.
   *
   * @remarks
   * This matrix transforms vectors from local space of this node to local space
   * of this node's parent.
   */
  localToParent() {
    const matrix = new DOMMatrix();
    matrix.translateSelf(this.position.x(), this.position.y());
    matrix.rotateSelf(0, 0, this.rotation());
    matrix.scaleSelf(this.scale.x(), this.scale.y());
    return matrix;
  }
  /**
   * A matrix mapping composite space to world space.
   *
   * @remarks
   * Certain effects such as blur and shadows ignore the current transformation.
   * This matrix can be used to transform their parameters so that the effect
   * appears relative to the closes composite root.
   */
  compositeToWorld() {
    var _a;
    return ((_a = this.compositeRoot()) == null ? void 0 : _a.localToWorld()) ?? new DOMMatrix();
  }
  compositeRoot() {
    var _a;
    if (this.composite()) {
      return this;
    }
    return ((_a = this.parent()) == null ? void 0 : _a.compositeRoot()) ?? null;
  }
  compositeToLocal() {
    const root = this.compositeRoot();
    if (root) {
      const worldToLocal = this.worldToLocal();
      worldToLocal.m44 = 1;
      return root.localToWorld().multiply(worldToLocal);
    }
    return new DOMMatrix();
  }
  view() {
    return this.view2D;
  }
  /**
   * Add the given node(s) as the children of this node.
   *
   * @remarks
   * The nodes will be appended at the end of the children list.
   *
   * @example
   * ```tsx
   * const node = <Layout />;
   * node.add(<Rect />);
   * node.add(<Circle />);
   * ```
   * Result:
   * ```mermaid
   * graph TD;
   *   layout([Layout])
   *   circle([Circle])
   *   rect([Rect])
   *     layout-->rect;
   *     layout-->circle;
   * ```
   *
   * @param node - A node or an array of nodes to append.
   */
  add(node) {
    return this.insert(node, Infinity);
  }
  /**
   * Insert the given node(s) at the specified index in the children list.
   *
   * @example
   * ```tsx
   * const node = (
   *   <Layout>
   *     <Rect />
   *     <Circle />
   *   </Layout>
   * );
   *
   * node.insert(<Txt />, 1);
   * ```
   *
   * Result:
   * ```mermaid
   * graph TD;
   *   layout([Layout])
   *   circle([Circle])
   *   text([Text])
   *   rect([Rect])
   *     layout-->rect;
   *     layout-->text;
   *     layout-->circle;
   * ```
   *
   * @param node - A node or an array of nodes to insert.
   * @param index - An index at which to insert the node(s).
   */
  insert(node, index = 0) {
    const array = Array.isArray(node) ? node : [node];
    if (array.length === 0) {
      return this;
    }
    const children = this.children();
    const newChildren = children.slice(0, index);
    for (const node2 of array) {
      if (node2 instanceof Node) {
        newChildren.push(node2);
        node2.remove();
        node2.parent(this);
      }
    }
    newChildren.push(...children.slice(index));
    this.children(newChildren);
    return this;
  }
  /**
   * Remove this node from the tree.
   */
  remove() {
    const current = this.parent();
    if (current === null) {
      return this;
    }
    current.children(current.children().filter((child) => child !== this));
    this.parent(null);
    return this;
  }
  /**
   * Rearrange this node in relation to its siblings.
   *
   * @remarks
   * Children are rendered starting from the beginning of the children list.
   * We can change the rendering order by rearranging said list.
   *
   * A positive `by` arguments move the node up (it will be rendered on top of
   * the elements it has passed). Negative values move it down.
   *
   * @param by - Number of places by which the node should be moved.
   */
  move(by = 1) {
    const parent = this.parent();
    if (by === 0 || !parent) {
      return this;
    }
    const children = parent.children();
    const newChildren = [];
    if (by > 0) {
      for (let i = 0; i < children.length; i++) {
        const child = children[i];
        if (child === this) {
          const target = i + by;
          for (; i < target && i + 1 < children.length; i++) {
            newChildren[i] = children[i + 1];
          }
        }
        newChildren[i] = child;
      }
    } else {
      for (let i = children.length - 1; i >= 0; i--) {
        const child = children[i];
        if (child === this) {
          const target = i + by;
          for (; i > target && i > 0; i--) {
            newChildren[i] = children[i - 1];
          }
        }
        newChildren[i] = child;
      }
    }
    parent.children(newChildren);
    return this;
  }
  /**
   * Move the node up in relation to its siblings.
   *
   * @remarks
   * The node will exchange places with the sibling right above it (if any) and
   * from then on will be rendered on top of it.
   */
  moveUp() {
    return this.move(1);
  }
  /**
   * Move the node down in relation to its siblings.
   *
   * @remarks
   * The node will exchange places with the sibling right below it (if any) and
   * from then on will be rendered under it.
   */
  moveDown() {
    return this.move(-1);
  }
  /**
   * Move the node to the top in relation to its siblings.
   *
   * @remarks
   * The node will be placed at the end of the children list and from then on
   * will be rendered on top of all of its siblings.
   */
  moveToTop() {
    return this.move(Infinity);
  }
  /**
   * Move the node to the bottom in relation to its siblings.
   *
   * @remarks
   * The node will be placed at the beginning of the children list and from then
   * on will be rendered below all of its siblings.
   */
  moveToBottom() {
    return this.move(-Infinity);
  }
  /**
   * Move the node to the provided position relative to its siblings.
   *
   * @remarks
   * If the node is getting moved to a lower position, it will be placed below
   * the sibling that's currently at the provided index (if any).
   * If the node is getting moved to a higher position, it will be placed above
   * the sibling that's currently at the provided index (if any).
   *
   * @param index - The index to move the node to.
   */
  moveTo(index) {
    const parent = this.parent();
    if (!parent) {
      return this;
    }
    const currentIndex = parent.children().indexOf(this);
    const by = index - currentIndex;
    return this.move(by);
  }
  /**
   * Move the node below the provided node in the parent's layout.
   *
   * @remarks
   * The node will be moved below the provided node and from then on will be
   * rendered below it. By default, if the node is already positioned lower than
   * the sibling node, it will not get moved.
   *
   * @param node - The sibling node below which to move.
   * @param directlyBelow - Whether the node should be positioned directly below
   *                        the sibling. When true, will move the node even if
   *                        it is already positioned below the sibling.
   */
  moveBelow(node, directlyBelow = false) {
    const parent = this.parent();
    if (!parent) {
      return this;
    }
    if (node.parent() !== parent) {
      useLogger().error("Cannot position nodes relative to each other if they don't belong to the same parent.");
      return this;
    }
    const children = parent.children();
    const ownIndex = children.indexOf(this);
    const otherIndex = children.indexOf(node);
    if (!directlyBelow && ownIndex < otherIndex) {
      return this;
    }
    const by = otherIndex - ownIndex - 1;
    return this.move(by);
  }
  /**
   * Move the node above the provided node in the parent's layout.
   *
   * @remarks
   * The node will be moved above the provided node and from then on will be
   * rendered on top of it. By default, if the node is already positioned
   * higher than the sibling node, it will not get moved.
   *
   * @param node - The sibling node below which to move.
   * @param directlyAbove - Whether the node should be positioned directly above the
   *                        sibling. When true, will move the node even if it is
   *                        already positioned above the sibling.
   */
  moveAbove(node, directlyAbove = false) {
    const parent = this.parent();
    if (!parent) {
      return this;
    }
    if (node.parent() !== parent) {
      useLogger().error("Cannot position nodes relative to each other if they don't belong to the same parent.");
      return this;
    }
    const children = parent.children();
    const ownIndex = children.indexOf(this);
    const otherIndex = children.indexOf(node);
    if (!directlyAbove && ownIndex > otherIndex) {
      return this;
    }
    const by = otherIndex - ownIndex + 1;
    return this.move(by);
  }
  /**
   * Change the parent of this node while keeping the absolute transform.
   *
   * @remarks
   * After performing this operation, the node will stay in the same place
   * visually, but its parent will be changed.
   *
   * @param newParent - The new parent of this node.
   */
  reparent(newParent) {
    const position = this.absolutePosition();
    const rotation = this.absoluteRotation();
    const scale = this.absoluteScale();
    newParent.add(this);
    this.absolutePosition(position);
    this.absoluteRotation(rotation);
    this.absoluteScale(scale);
  }
  /**
   * Remove all children of this node.
   */
  removeChildren() {
    for (const node of this.children()) {
      node.remove();
    }
  }
  /**
   * Prepare this node to be disposed of.
   *
   * @remarks
   * This method is called automatically when a scene is refreshed. It will
   * be called even if the node is not currently attached to the tree.
   *
   * The goal of this method is to clean any external references to allow the
   * node to be garbage collected.
   */
  dispose() {
    this.stateStack = [];
    for (const { signal: signal2 } of this) {
      signal2 == null ? void 0 : signal2.context.dispose();
    }
  }
  /**
   * Create a copy of this node.
   *
   * @param customProps - Properties to override.
   */
  clone(customProps = {}) {
    const props = { ...customProps };
    if (isReactive(this.spawner.context.raw())) {
      props.spawner = this.spawner.context.raw();
    } else if (this.children().length > 0) {
      props.children ?? (props.children = this.children().map((child) => child.clone()));
    }
    for (const { key, meta, signal: signal2 } of this) {
      if (!meta.cloneable || key in props)
        continue;
      if (meta.compound) {
        for (const [key2, property] of meta.compoundEntries) {
          if (property in props)
            continue;
          props[property] = signal2[key2].context.raw();
        }
      } else {
        props[key] = signal2.context.raw();
      }
    }
    return this.instantiate(props);
  }
  /**
   * Create a copy of this node.
   *
   * @remarks
   * Unlike {@link clone}, a snapshot clone calculates any reactive properties
   * at the moment of cloning and passes the raw values to the copy.
   *
   * @param customProps - Properties to override.
   */
  snapshotClone(customProps = {}) {
    const props = {
      ...this.getState(),
      ...customProps
    };
    if (this.children().length > 0) {
      props.children ?? (props.children = this.children().map((child) => child.snapshotClone()));
    }
    return this.instantiate(props);
  }
  /**
   * Create a reactive copy of this node.
   *
   * @remarks
   * A reactive copy has all its properties dynamically updated to match the
   * source node.
   *
   * @param customProps - Properties to override.
   */
  reactiveClone(customProps = {}) {
    const props = { ...customProps };
    if (this.children().length > 0) {
      props.children ?? (props.children = this.children().map((child) => child.reactiveClone()));
    }
    for (const { key, meta, signal: signal2 } of this) {
      if (!meta.cloneable || key in props)
        continue;
      props[key] = () => signal2();
    }
    return this.instantiate(props);
  }
  /**
   * Create an instance of this node's class.
   *
   * @param props - Properties to pass to the constructor.
   */
  instantiate(props = {}) {
    return new this.constructor(props);
  }
  /**
   * Whether this node should be cached or not.
   */
  requiresCache() {
    return this.cache() || this.opacity() < 1 || this.compositeOperation() !== "source-over" || this.hasFilters() || this.hasShadow();
  }
  cacheCanvas() {
    const canvas = document.createElement("canvas").getContext("2d");
    if (!canvas) {
      throw new Error("Could not create a cache canvas");
    }
    return canvas;
  }
  /**
   * Get a cache canvas with the contents of this node rendered onto it.
   */
  cachedCanvas() {
    const context = this.cacheCanvas();
    const cache = this.worldSpaceCacheBBox();
    const matrix = this.localToWorld();
    context.canvas.width = cache.width;
    context.canvas.height = cache.height;
    context.setTransform(matrix.a, matrix.b, matrix.c, matrix.d, matrix.e - cache.x, matrix.f - cache.y);
    this.draw(context);
    return context;
  }
  /**
   * Get a bounding box for the contents rendered by this node.
   *
   * @remarks
   * The returned bounding box should be in local space.
   */
  getCacheBBox() {
    return new BBox();
  }
  /**
   * Get a bounding box for the contents rendered by this node as well
   * as its children.
   */
  cacheBBox() {
    const cache = this.getCacheBBox();
    const children = this.children();
    if (children.length === 0) {
      return cache;
    }
    const points = cache.corners;
    for (const child of children) {
      const childCache = child.fullCacheBBox();
      const childMatrix = child.localToParent();
      points.push(...childCache.corners.map((r) => r.transformAsPoint(childMatrix)));
    }
    return BBox.fromPoints(...points);
  }
  /**
   * Get a bounding box for the contents rendered by this node (including
   * effects applied after caching).
   *
   * @remarks
   * The returned bounding box should be in local space.
   */
  fullCacheBBox() {
    const matrix = this.compositeToLocal();
    const shadowOffset = this.shadowOffset().transform(matrix);
    const shadowBlur = transformScalar(this.shadowBlur(), matrix);
    const result = this.cacheBBox().expand(this.filters.blur() * 2 + shadowBlur);
    if (shadowOffset.x < 0) {
      result.x += shadowOffset.x;
      result.width -= shadowOffset.x;
    } else {
      result.width += shadowOffset.x;
    }
    if (shadowOffset.y < 0) {
      result.y += shadowOffset.y;
      result.height -= shadowOffset.y;
    } else {
      result.height += shadowOffset.y;
    }
    return result;
  }
  /**
   * Get a bounding box in world space for the contents rendered by this node as
   * well as its children.
   *
   * @remarks
   * This is the same the bounding box returned by {@link cacheBBox} only
   * transformed to world space.
   */
  worldSpaceCacheBBox() {
    const viewBBox = BBox.fromSizeCentered(this.view().size());
    const canvasBBox = BBox.fromPoints(...viewBBox.transformCorners(this.view().localToWorld()));
    const cacheBBox = BBox.fromPoints(...this.cacheBBox().transformCorners(this.localToWorld()));
    return canvasBBox.intersection(cacheBBox).pixelPerfect;
  }
  /**
   * Prepare the given context for drawing a cached node onto it.
   *
   * @remarks
   * This method is called before the contents of the cache canvas are drawn
   * on the screen. It can be used to apply effects to the entire node together
   * with its children, instead of applying them individually.
   * Effects such as transparency, shadows, and filters use this technique.
   *
   * Whether the node is cached is decided by the {@link requiresCache} method.
   *
   * @param context - The context using which the cache will be drawn.
   */
  setupDrawFromCache(context) {
    context.globalCompositeOperation = this.compositeOperation();
    context.globalAlpha *= this.opacity();
    if (this.hasFilters()) {
      context.filter = this.filterString();
    }
    if (this.hasShadow()) {
      const matrix = this.compositeToWorld();
      const offset = this.shadowOffset().transform(matrix);
      const blur = transformScalar(this.shadowBlur(), matrix);
      context.shadowColor = this.shadowColor().serialize();
      context.shadowBlur = blur;
      context.shadowOffsetX = offset.x;
      context.shadowOffsetY = offset.y;
    }
  }
  /**
   * Render this node onto the given canvas.
   *
   * @param context - The context to draw with.
   */
  render(context) {
    if (this.absoluteOpacity() <= 0) {
      return;
    }
    context.save();
    this.transformContext(context);
    if (this.requiresCache()) {
      const cacheRect = this.worldSpaceCacheBBox();
      if (cacheRect.width !== 0 && cacheRect.height !== 0) {
        this.setupDrawFromCache(context);
        const cacheContext = this.cachedCanvas();
        const compositeOverride = this.compositeOverride();
        const matrix = this.worldToLocal();
        context.transform(matrix.a, matrix.b, matrix.c, matrix.d, matrix.e, matrix.f);
        context.drawImage(cacheContext.canvas, cacheRect.position.x, cacheRect.position.y);
        if (compositeOverride > 0) {
          context.save();
          context.globalAlpha *= compositeOverride;
          context.globalCompositeOperation = "source-over";
          context.drawImage(cacheContext.canvas, cacheRect.position.x, cacheRect.position.y);
          context.restore();
        }
      }
    } else {
      this.draw(context);
    }
    context.restore();
  }
  /**
   * Draw this node onto the canvas.
   *
   * @remarks
   * This method is used when drawing directly onto the screen as well as onto
   * the cache canvas.
   * It assumes that the context have already been transformed to local space.
   *
   * @param context - The context to draw with.
   */
  draw(context) {
    this.drawChildren(context);
  }
  drawChildren(context) {
    for (const child of this.sortedChildren()) {
      child.render(context);
    }
  }
  /**
   * Draw an overlay for this node.
   *
   * @remarks
   * The overlay for the currently inspected node is displayed on top of the
   * canvas.
   *
   * The provided context is in screen space. The local-to-screen matrix can be
   * used to transform all shapes that need to be displayed.
   * This approach allows to keep the line widths and gizmo sizes consistent,
   * no matter how zoomed-in the view is.
   *
   * @param context - The context to draw with.
   * @param matrix - A local-to-screen matrix.
   */
  drawOverlay(context, matrix) {
    const box = this.cacheBBox().transformCorners(matrix);
    const cache = this.getCacheBBox().transformCorners(matrix);
    context.strokeStyle = "white";
    context.lineWidth = 1;
    context.beginPath();
    drawLine(context, box);
    context.closePath();
    context.stroke();
    context.strokeStyle = "blue";
    context.beginPath();
    drawLine(context, cache);
    context.closePath();
    context.stroke();
  }
  transformContext(context) {
    const matrix = this.localToParent();
    context.transform(matrix.a, matrix.b, matrix.c, matrix.d, matrix.e, matrix.f);
  }
  /**
   * Try to find a node intersecting the given position.
   *
   * @param position - The searched position.
   */
  hit(position) {
    let hit = null;
    const local = position.transformAsPoint(this.localToParent().inverse());
    for (const child of this.children().reverse()) {
      hit = child.hit(local);
      if (hit) {
        break;
      }
    }
    return hit;
  }
  /**
   * Collect all asynchronous resources used by this node.
   */
  collectAsyncResources() {
    for (const child of this.children()) {
      child.collectAsyncResources();
    }
  }
  /**
   * Wait for any asynchronous resources that this node or its children have.
   *
   * @remarks
   * Certain resources like images are always loaded asynchronously.
   * Awaiting this method makes sure that all such resources are done loading
   * before continuing the animation.
   */
  async toPromise() {
    let promises = DependencyContext.consumePromises();
    do {
      await Promise.all(promises.map((handle) => handle.promise));
      this.collectAsyncResources();
      promises = DependencyContext.consumePromises();
    } while (promises.length > 0);
    return this;
  }
  /**
   * Return a snapshot of the node's current signal values.
   *
   * @remarks
   * This method will calculate the values of any reactive properties of the
   * node at the time the method is called.
   */
  getState() {
    const state = {};
    for (const { key, meta, signal: signal2 } of this) {
      if (!meta.cloneable || key in state)
        continue;
      state[key] = signal2();
    }
    return state;
  }
  /**
   * Apply the given state to the node, setting all matching signal values to
   * the provided values.
   *
   * @param state - The state to apply to the node.
   */
  applyState(state) {
    for (const key in state) {
      const signal2 = this.signalByKey(key);
      if (signal2) {
        signal2(state[key]);
      }
    }
  }
  /**
   * Push a snapshot of the node's current state onto the node's state stack.
   *
   * @remarks
   * This method can be used together with the {@link restore} method to save a
   * node's current state and later restore it. It is possible to store more
   * than one state by calling `save` method multiple times.
   */
  save() {
    this.stateStack.push(this.getState());
  }
  /**
   * Restore the node to its last saved state.
   *
   * @remarks
   * This method can be used together with the {@link save} method to restore a
   * node to a previously saved state. Restoring a node to a previous state
   * removes that state from the state stack.
   *
   * @example
   * ```tsx
   * const node = <Circle width={100} height={100} fill={"lightseagreen"} />
   *
   * view.add(node);
   *
   * // Save the node's current state
   * node.save();
   *
   * // Modify some of the node's properties
   * yield* node.scale(2, 1);
   * yield* node.fill('hotpink', 1);
   *
   * // Restore the node to its saved state over 1 second
   * yield* node.restore(1);
   * ```
   *
   * @param duration - The duration of the transition
   * @param timing - The timing function to use for the transition
   */
  restore(duration, timing = easeInOutCubic) {
    const state = this.stateStack.pop();
    if (state === void 0) {
      return;
    }
    const currentState = this.getState();
    for (const key in state) {
      if (currentState[key] === state[key]) {
        delete state[key];
      }
    }
    return tween(duration, (value) => {
      const t = timing(value);
      const nextState = Object.keys(state).reduce((newState, key) => {
        newState[key] = deepLerp(currentState[key], state[key], t);
        return newState;
      }, {});
      this.applyState(nextState);
    });
  }
  *[Symbol.iterator]() {
    for (const key in this.properties) {
      const meta = this.properties[key];
      const signal2 = this.signalByKey(key);
      yield { meta, signal: signal2, key };
    }
  }
  signalByKey(key) {
    return this[key];
  }
};
__decorate([
  vector2Signal()
], Node.prototype, "position", void 0);
__decorate([
  wrapper(Vector2),
  cloneable(false),
  signal()
], Node.prototype, "absolutePosition", void 0);
__decorate([
  initial(0),
  signal()
], Node.prototype, "rotation", void 0);
__decorate([
  cloneable(false),
  signal()
], Node.prototype, "absoluteRotation", void 0);
__decorate([
  initial(Vector2.one),
  vector2Signal("scale")
], Node.prototype, "scale", void 0);
__decorate([
  wrapper(Vector2),
  cloneable(false),
  signal()
], Node.prototype, "absoluteScale", void 0);
__decorate([
  initial(0),
  signal()
], Node.prototype, "zIndex", void 0);
__decorate([
  initial(false),
  signal()
], Node.prototype, "cache", void 0);
__decorate([
  initial(false),
  signal()
], Node.prototype, "composite", void 0);
__decorate([
  initial("source-over"),
  signal()
], Node.prototype, "compositeOperation", void 0);
__decorate([
  threadable()
], Node.prototype, "tweenCompositeOperation", null);
__decorate([
  initial(1),
  signal()
], Node.prototype, "opacity", void 0);
__decorate([
  computed()
], Node.prototype, "absoluteOpacity", null);
__decorate([
  filtersSignal()
], Node.prototype, "filters", void 0);
__decorate([
  initial("#0000"),
  colorSignal()
], Node.prototype, "shadowColor", void 0);
__decorate([
  initial(0),
  signal()
], Node.prototype, "shadowBlur", void 0);
__decorate([
  vector2Signal("shadowOffset")
], Node.prototype, "shadowOffset", void 0);
__decorate([
  computed()
], Node.prototype, "hasFilters", null);
__decorate([
  computed()
], Node.prototype, "hasShadow", null);
__decorate([
  computed()
], Node.prototype, "filterString", null);
__decorate([
  inspectable(false),
  cloneable(false),
  initial([]),
  signal()
], Node.prototype, "spawner", void 0);
__decorate([
  inspectable(false),
  cloneable(false),
  signal()
], Node.prototype, "children", void 0);
__decorate([
  computed()
], Node.prototype, "spawnChildren", null);
__decorate([
  computed()
], Node.prototype, "sortedChildren", null);
__decorate([
  computed()
], Node.prototype, "localToWorld", null);
__decorate([
  computed()
], Node.prototype, "worldToLocal", null);
__decorate([
  computed()
], Node.prototype, "worldToParent", null);
__decorate([
  computed()
], Node.prototype, "localToParent", null);
__decorate([
  computed()
], Node.prototype, "compositeToWorld", null);
__decorate([
  computed()
], Node.prototype, "compositeRoot", null);
__decorate([
  computed()
], Node.prototype, "compositeToLocal", null);
__decorate([
  computed()
], Node.prototype, "cacheCanvas", null);
__decorate([
  computed()
], Node.prototype, "cachedCanvas", null);
__decorate([
  computed()
], Node.prototype, "cacheBBox", null);
__decorate([
  computed()
], Node.prototype, "fullCacheBBox", null);
__decorate([
  computed()
], Node.prototype, "worldSpaceCacheBBox", null);
Node.prototype.isClass = true;

// node_modules/@motion-canvas/2d/lib/decorators/spacingSignal.js
function spacingSignal(prefix) {
  return (target, key) => {
    compound({
      top: prefix ? `${prefix}Top` : "top",
      right: prefix ? `${prefix}Right` : "right",
      bottom: prefix ? `${prefix}Bottom` : "bottom",
      left: prefix ? `${prefix}Left` : "left"
    })(target, key);
    wrapper(Spacing)(target, key);
  };
}

// node_modules/@motion-canvas/2d/lib/components/Layout.js
var __decorate2 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var Layout = class extends Node {
  get columnGap() {
    return this.gap.x;
  }
  get rowGap() {
    return this.gap.y;
  }
  getX() {
    if (this.isLayoutRoot()) {
      return this.customX();
    }
    return this.computedPosition().x;
  }
  setX(value) {
    this.customX(value);
  }
  getY() {
    if (this.isLayoutRoot()) {
      return this.customY();
    }
    return this.computedPosition().y;
  }
  setY(value) {
    this.customY(value);
  }
  get width() {
    return this.size.x;
  }
  get height() {
    return this.size.y;
  }
  getWidth() {
    return this.computedSize().width;
  }
  setWidth(value) {
    this.customWidth(value);
  }
  *tweenWidth(value, time, timingFunction, interpolationFunction) {
    const width = this.desiredSize().x;
    const lock = typeof width !== "number" || typeof value !== "number";
    let from;
    if (lock) {
      from = this.size.x();
    } else {
      from = width;
    }
    let to;
    if (lock) {
      this.size.x(value);
      to = this.size.x();
    } else {
      to = value;
    }
    this.size.x(from);
    lock && this.lockSize();
    yield* tween(time, (value2) => this.size.x(interpolationFunction(from, to, timingFunction(value2))));
    this.size.x(value);
    lock && this.releaseSize();
  }
  getHeight() {
    return this.computedSize().height;
  }
  setHeight(value) {
    this.customHeight(value);
  }
  *tweenHeight(value, time, timingFunction, interpolationFunction) {
    const height = this.desiredSize().y;
    const lock = typeof height !== "number" || typeof value !== "number";
    let from;
    if (lock) {
      from = this.size.y();
    } else {
      from = height;
    }
    let to;
    if (lock) {
      this.size.y(value);
      to = this.size.y();
    } else {
      to = value;
    }
    this.size.y(from);
    lock && this.lockSize();
    yield* tween(time, (value2) => this.size.y(interpolationFunction(from, to, timingFunction(value2))));
    this.size.y(value);
    lock && this.releaseSize();
  }
  /**
   * Get the desired size of this node.
   *
   * @remarks
   * This method can be used to control the size using external factors.
   * By default, the returned size is the same as the one declared by the user.
   */
  desiredSize() {
    return {
      x: this.customWidth(),
      y: this.customHeight()
    };
  }
  *tweenSize(value, time, timingFunction, interpolationFunction) {
    const size = this.desiredSize();
    let from;
    if (typeof size.x !== "number" || typeof size.y !== "number") {
      from = this.size();
    } else {
      from = new Vector2(size);
    }
    let to;
    if (typeof value === "object" && typeof value.x === "number" && typeof value.y === "number") {
      to = new Vector2(value);
    } else {
      this.size(value);
      to = this.size();
    }
    this.size(from);
    this.lockSize();
    yield* tween(time, (value2) => this.size(interpolationFunction(from, to, timingFunction(value2))));
    this.releaseSize();
    this.size(value);
  }
  constructor({ tagName = "div", ...props }) {
    super(props);
    this.sizeLockCounter = createSignal(0);
    this.element = document.createElement(tagName);
    this.element.style.display = "flex";
    this.element.style.boxSizing = "border-box";
    this.styles = getComputedStyle(this.element);
  }
  lockSize() {
    this.sizeLockCounter(this.sizeLockCounter() + 1);
  }
  releaseSize() {
    this.sizeLockCounter(this.sizeLockCounter() - 1);
  }
  parentTransform() {
    let parent = this.parent();
    while (parent) {
      if (parent instanceof Layout) {
        return parent;
      }
      parent = parent.parent();
    }
    return null;
  }
  anchorPosition() {
    const size = this.computedSize();
    const offset = this.offset();
    return size.scale(0.5).mul(offset);
  }
  /**
   * Get the resolved layout mode of this node.
   *
   * @remarks
   * When the mode is `null`, its value will be inherited from the parent.
   *
   * Use {@link layout} to get the raw mode set for this node (without
   * inheritance).
   */
  layoutEnabled() {
    var _a;
    return this.layout() ?? ((_a = this.parentTransform()) == null ? void 0 : _a.layoutEnabled()) ?? false;
  }
  isLayoutRoot() {
    var _a;
    return !this.layoutEnabled() || !((_a = this.parentTransform()) == null ? void 0 : _a.layoutEnabled());
  }
  localToParent() {
    const matrix = new DOMMatrix();
    const offset = this.size().mul(this.offset()).scale(-0.5);
    matrix.translateSelf(this.position.x(), this.position.y());
    matrix.rotateSelf(0, 0, this.rotation());
    matrix.scaleSelf(this.scale.x(), this.scale.y());
    matrix.translateSelf(offset.x, offset.y);
    return matrix;
  }
  getComputedLayout() {
    return new BBox(this.element.getBoundingClientRect());
  }
  computedPosition() {
    this.requestLayoutUpdate();
    const box = this.getComputedLayout();
    const position = new Vector2(box.x + box.width / 2 * this.offset.x(), box.y + box.height / 2 * this.offset.y());
    const parent = this.parentTransform();
    if (parent) {
      const parentRect = parent.getComputedLayout();
      position.x -= parentRect.x + (parentRect.width - box.width) / 2;
      position.y -= parentRect.y + (parentRect.height - box.height) / 2;
    }
    return position;
  }
  computedSize() {
    this.requestLayoutUpdate();
    return this.getComputedLayout().size;
  }
  /**
   * Find the closest layout root and apply any new layout changes.
   */
  requestLayoutUpdate() {
    const parent = this.parentTransform();
    if (this.appendedToView()) {
      parent == null ? void 0 : parent.requestFontUpdate();
      this.updateLayout();
    } else {
      parent.requestLayoutUpdate();
    }
  }
  appendedToView() {
    const root = this.isLayoutRoot();
    if (root) {
      this.view().element.append(this.element);
    }
    return root;
  }
  /**
   * Apply any new layout changes to this node and its children.
   */
  updateLayout() {
    this.applyFont();
    this.applyFlex();
    if (this.layoutEnabled()) {
      const children = this.layoutChildren();
      for (const child of children) {
        child.updateLayout();
      }
    }
  }
  layoutChildren() {
    const queue = [...this.children()];
    const result = [];
    const elements = [];
    while (queue.length) {
      const child = queue.shift();
      if (child instanceof Layout) {
        result.push(child);
        elements.push(child.element);
      } else if (child) {
        queue.unshift(...child.children());
      }
    }
    this.element.replaceChildren(...elements);
    return result;
  }
  /**
   * Apply any new font changes to this node and all of its ancestors.
   */
  requestFontUpdate() {
    var _a;
    (_a = this.parentTransform()) == null ? void 0 : _a.requestFontUpdate();
    this.applyFont();
  }
  getCacheBBox() {
    return BBox.fromSizeCentered(this.computedSize());
  }
  draw(context) {
    if (this.clip()) {
      const size = this.computedSize();
      if (size.width === 0 || size.height === 0) {
        return;
      }
      context.beginPath();
      context.rect(size.width / -2, size.height / -2, size.width, size.height);
      context.closePath();
      context.clip();
    }
    this.drawChildren(context);
  }
  drawOverlay(context, matrix) {
    const size = this.computedSize();
    const offset = size.mul(this.offset()).scale(0.5).transformAsPoint(matrix);
    const box = BBox.fromSizeCentered(size);
    const layout = box.transformCorners(matrix);
    const padding = box.addSpacing(this.padding().scale(-1)).transformCorners(matrix);
    const margin = box.addSpacing(this.margin()).transformCorners(matrix);
    context.beginPath();
    drawLine(context, margin);
    drawLine(context, layout);
    context.closePath();
    context.fillStyle = "rgba(255,193,125,0.6)";
    context.fill("evenodd");
    context.beginPath();
    drawLine(context, layout);
    drawLine(context, padding);
    context.closePath();
    context.fillStyle = "rgba(180,255,147,0.6)";
    context.fill("evenodd");
    context.beginPath();
    drawLine(context, layout);
    context.closePath();
    context.lineWidth = 1;
    context.strokeStyle = "white";
    context.stroke();
    const radius = 8;
    context.beginPath();
    lineTo(context, offset.addY(-radius));
    lineTo(context, offset.addY(radius));
    lineTo(context, offset);
    lineTo(context, offset.addX(-radius));
    context.arc(offset.x, offset.y, radius, 0, Math.PI * 2);
    context.stroke();
  }
  getOriginDelta(origin) {
    const size = this.computedSize().scale(0.5);
    const offset = this.offset().mul(size);
    if (origin === Origin.Middle) {
      return offset.flipped;
    }
    const newOffset = originToOffset(origin).mul(size);
    return newOffset.sub(offset);
  }
  /**
   * Update the offset of this node and adjust the position to keep it in the
   * same place.
   *
   * @param offset - The new offset.
   */
  moveOffset(offset) {
    const size = this.computedSize().scale(0.5);
    const oldOffset = this.offset().mul(size);
    const newOffset = offset.mul(size);
    this.offset(offset);
    this.position(this.position().add(newOffset).sub(oldOffset));
  }
  parsePixels(value) {
    return value === null ? "" : `${value}px`;
  }
  parseLength(value) {
    if (value === null) {
      return "";
    }
    if (typeof value === "string") {
      return value;
    }
    return `${value}px`;
  }
  applyFlex() {
    this.element.style.position = this.isLayoutRoot() ? "absolute" : "relative";
    const size = this.desiredSize();
    this.element.style.width = this.parseLength(size.x);
    this.element.style.height = this.parseLength(size.y);
    this.element.style.maxWidth = this.parseLength(this.maxWidth());
    this.element.style.minWidth = this.parseLength(this.minWidth());
    this.element.style.maxHeight = this.parseLength(this.maxHeight());
    this.element.style.minHeight = this.parseLength(this.minHeight());
    this.element.style.aspectRatio = this.ratio() === null ? "" : this.ratio().toString();
    this.element.style.marginTop = this.parsePixels(this.margin.top());
    this.element.style.marginBottom = this.parsePixels(this.margin.bottom());
    this.element.style.marginLeft = this.parsePixels(this.margin.left());
    this.element.style.marginRight = this.parsePixels(this.margin.right());
    this.element.style.paddingTop = this.parsePixels(this.padding.top());
    this.element.style.paddingBottom = this.parsePixels(this.padding.bottom());
    this.element.style.paddingLeft = this.parsePixels(this.padding.left());
    this.element.style.paddingRight = this.parsePixels(this.padding.right());
    this.element.style.flexDirection = this.direction();
    this.element.style.flexBasis = this.parseLength(this.basis());
    this.element.style.flexWrap = this.wrap();
    this.element.style.justifyContent = this.justifyContent();
    this.element.style.alignContent = this.alignContent();
    this.element.style.alignItems = this.alignItems();
    this.element.style.alignSelf = this.alignSelf();
    this.element.style.columnGap = this.parseLength(this.gap.x());
    this.element.style.rowGap = this.parseLength(this.gap.y());
    if (this.sizeLockCounter() > 0) {
      this.element.style.flexGrow = "0";
      this.element.style.flexShrink = "0";
    } else {
      this.element.style.flexGrow = this.grow().toString();
      this.element.style.flexShrink = this.shrink().toString();
    }
  }
  applyFont() {
    this.element.style.fontFamily = this.fontFamily.isInitial() ? "" : this.fontFamily();
    this.element.style.fontSize = this.fontSize.isInitial() ? "" : `${this.fontSize()}px`;
    this.element.style.fontStyle = this.fontStyle.isInitial() ? "" : this.fontStyle();
    if (this.lineHeight.isInitial()) {
      this.element.style.lineHeight = "";
    } else {
      const lineHeight = this.lineHeight();
      this.element.style.lineHeight = typeof lineHeight === "string" ? (parseFloat(lineHeight) / 100).toString() : `${lineHeight}px`;
    }
    this.element.style.fontWeight = this.fontWeight.isInitial() ? "" : this.fontWeight().toString();
    this.element.style.letterSpacing = this.letterSpacing.isInitial() ? "" : `${this.letterSpacing()}px`;
    this.element.style.textAlign = this.textAlign.isInitial() ? "" : this.textAlign();
    if (this.textWrap.isInitial()) {
      this.element.style.whiteSpace = "";
    } else {
      const wrap = this.textWrap();
      if (typeof wrap === "boolean") {
        this.element.style.whiteSpace = wrap ? "normal" : "nowrap";
      } else {
        this.element.style.whiteSpace = wrap;
      }
    }
  }
  dispose() {
    var _a;
    super.dispose();
    (_a = this.sizeLockCounter) == null ? void 0 : _a.context.dispose();
    if (this.element) {
      this.element.remove();
      this.element.innerHTML = "";
    }
    this.element = null;
    this.styles = null;
  }
  hit(position) {
    const local = position.transformAsPoint(this.localToParent().inverse());
    if (this.cacheBBox().includes(local)) {
      return super.hit(position) ?? this;
    }
    return null;
  }
};
__decorate2([
  initial(null),
  signal()
], Layout.prototype, "layout", void 0);
__decorate2([
  initial(null),
  signal()
], Layout.prototype, "maxWidth", void 0);
__decorate2([
  initial(null),
  signal()
], Layout.prototype, "maxHeight", void 0);
__decorate2([
  initial(null),
  signal()
], Layout.prototype, "minWidth", void 0);
__decorate2([
  initial(null),
  signal()
], Layout.prototype, "minHeight", void 0);
__decorate2([
  initial(null),
  signal()
], Layout.prototype, "ratio", void 0);
__decorate2([
  spacingSignal("margin")
], Layout.prototype, "margin", void 0);
__decorate2([
  spacingSignal("padding")
], Layout.prototype, "padding", void 0);
__decorate2([
  initial("row"),
  signal()
], Layout.prototype, "direction", void 0);
__decorate2([
  initial(null),
  signal()
], Layout.prototype, "basis", void 0);
__decorate2([
  initial(0),
  signal()
], Layout.prototype, "grow", void 0);
__decorate2([
  initial(1),
  signal()
], Layout.prototype, "shrink", void 0);
__decorate2([
  initial("nowrap"),
  signal()
], Layout.prototype, "wrap", void 0);
__decorate2([
  initial("start"),
  signal()
], Layout.prototype, "justifyContent", void 0);
__decorate2([
  initial("normal"),
  signal()
], Layout.prototype, "alignContent", void 0);
__decorate2([
  initial("stretch"),
  signal()
], Layout.prototype, "alignItems", void 0);
__decorate2([
  initial("auto"),
  signal()
], Layout.prototype, "alignSelf", void 0);
__decorate2([
  initial(0),
  vector2Signal({ x: "columnGap", y: "rowGap" })
], Layout.prototype, "gap", void 0);
__decorate2([
  defaultStyle("font-family"),
  signal()
], Layout.prototype, "fontFamily", void 0);
__decorate2([
  defaultStyle("font-size", parseFloat),
  signal()
], Layout.prototype, "fontSize", void 0);
__decorate2([
  defaultStyle("font-style"),
  signal()
], Layout.prototype, "fontStyle", void 0);
__decorate2([
  defaultStyle("font-weight", parseInt),
  signal()
], Layout.prototype, "fontWeight", void 0);
__decorate2([
  defaultStyle("line-height", parseFloat),
  signal()
], Layout.prototype, "lineHeight", void 0);
__decorate2([
  defaultStyle("letter-spacing", (i) => i === "normal" ? 0 : parseFloat(i)),
  signal()
], Layout.prototype, "letterSpacing", void 0);
__decorate2([
  defaultStyle("white-space", (i) => i === "pre" ? "pre" : i === "normal"),
  signal()
], Layout.prototype, "textWrap", void 0);
__decorate2([
  initial("inherit"),
  signal()
], Layout.prototype, "textDirection", void 0);
__decorate2([
  defaultStyle("text-align"),
  signal()
], Layout.prototype, "textAlign", void 0);
__decorate2([
  cloneable(false),
  inspectable(false),
  signal()
], Layout.prototype, "customX", void 0);
__decorate2([
  cloneable(false),
  inspectable(false),
  signal()
], Layout.prototype, "customY", void 0);
__decorate2([
  cloneable(false),
  initial({ x: null, y: null }),
  vector2Signal({ x: "width", y: "height" })
], Layout.prototype, "size", void 0);
__decorate2([
  inspectable(false),
  signal()
], Layout.prototype, "customWidth", void 0);
__decorate2([
  threadable()
], Layout.prototype, "tweenWidth", null);
__decorate2([
  inspectable(false),
  signal()
], Layout.prototype, "customHeight", void 0);
__decorate2([
  threadable()
], Layout.prototype, "tweenHeight", null);
__decorate2([
  computed()
], Layout.prototype, "desiredSize", null);
__decorate2([
  threadable()
], Layout.prototype, "tweenSize", null);
__decorate2([
  vector2Signal("offset")
], Layout.prototype, "offset", void 0);
__decorate2([
  initial(false),
  signal()
], Layout.prototype, "clip", void 0);
__decorate2([
  computed()
], Layout.prototype, "parentTransform", null);
__decorate2([
  computed()
], Layout.prototype, "anchorPosition", null);
__decorate2([
  computed()
], Layout.prototype, "layoutEnabled", null);
__decorate2([
  computed()
], Layout.prototype, "isLayoutRoot", null);
__decorate2([
  computed()
], Layout.prototype, "computedPosition", null);
__decorate2([
  computed()
], Layout.prototype, "computedSize", null);
__decorate2([
  computed()
], Layout.prototype, "requestLayoutUpdate", null);
__decorate2([
  computed()
], Layout.prototype, "appendedToView", null);
__decorate2([
  computed()
], Layout.prototype, "updateLayout", null);
__decorate2([
  computed()
], Layout.prototype, "layoutChildren", null);
__decorate2([
  computed()
], Layout.prototype, "requestFontUpdate", null);
__decorate2([
  computed()
], Layout.prototype, "applyFlex", null);
__decorate2([
  computed()
], Layout.prototype, "applyFont", null);

// node_modules/@motion-canvas/2d/lib/components/Shape.js
var __decorate3 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var Shape = class extends Layout {
  rippleSize() {
    return easeOutExpo(this.rippleStrength(), 0, 50);
  }
  constructor(props) {
    super(props);
    this.rippleStrength = createSignal(0);
  }
  applyText(context) {
    context.direction = this.textDirection();
    this.element.dir = this.textDirection();
  }
  applyStyle(context) {
    context.fillStyle = resolveCanvasStyle(this.fill(), context);
    context.strokeStyle = resolveCanvasStyle(this.stroke(), context);
    context.lineWidth = this.lineWidth();
    context.lineJoin = this.lineJoin();
    context.lineCap = this.lineCap();
    context.setLineDash(this.lineDash());
    context.lineDashOffset = this.lineDashOffset();
    if (!this.antialiased()) {
      context.filter = "url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciPjxmaWx0ZXIgaWQ9ImZpbHRlciIgeD0iMCIgeT0iMCIgd2lkdGg9IjEwMCUiIGhlaWdodD0iMTAwJSIgY29sb3ItaW50ZXJwb2xhdGlvbi1maWx0ZXJzPSJzUkdCIj48ZmVDb21wb25lbnRUcmFuc2Zlcj48ZmVGdW5jUiB0eXBlPSJpZGVudGl0eSIvPjxmZUZ1bmNHIHR5cGU9ImlkZW50aXR5Ii8+PGZlRnVuY0IgdHlwZT0iaWRlbnRpdHkiLz48ZmVGdW5jQSB0eXBlPSJkaXNjcmV0ZSIgdGFibGVWYWx1ZXM9IjAgMSIvPjwvZmVDb21wb25lbnRUcmFuc2Zlcj48L2ZpbHRlcj48L3N2Zz4=#filter)";
    }
  }
  draw(context) {
    this.drawShape(context);
    if (this.clip()) {
      context.clip(this.getPath());
    }
    this.drawChildren(context);
  }
  drawShape(context) {
    const path = this.getPath();
    const hasStroke = this.lineWidth() > 0 && this.stroke() !== null;
    const hasFill = this.fill() !== null;
    context.save();
    this.applyStyle(context);
    this.drawRipple(context);
    if (this.strokeFirst()) {
      hasStroke && context.stroke(path);
      hasFill && context.fill(path);
    } else {
      hasFill && context.fill(path);
      hasStroke && context.stroke(path);
    }
    context.restore();
  }
  getCacheBBox() {
    return super.getCacheBBox().expand(this.lineWidth() / 2);
  }
  getPath() {
    return new Path2D();
  }
  getRipplePath() {
    return new Path2D();
  }
  drawRipple(context) {
    const rippleStrength = this.rippleStrength();
    if (rippleStrength > 0) {
      const ripplePath = this.getRipplePath();
      context.save();
      context.globalAlpha *= map(0.54, 0, rippleStrength);
      context.fill(ripplePath);
      context.restore();
    }
  }
  *ripple(duration = 1) {
    this.rippleStrength(0);
    yield* this.rippleStrength(1, duration, linear);
    this.rippleStrength(0);
  }
};
__decorate3([
  canvasStyleSignal()
], Shape.prototype, "fill", void 0);
__decorate3([
  canvasStyleSignal()
], Shape.prototype, "stroke", void 0);
__decorate3([
  initial(false),
  signal()
], Shape.prototype, "strokeFirst", void 0);
__decorate3([
  initial(0),
  signal()
], Shape.prototype, "lineWidth", void 0);
__decorate3([
  initial("miter"),
  signal()
], Shape.prototype, "lineJoin", void 0);
__decorate3([
  initial("butt"),
  signal()
], Shape.prototype, "lineCap", void 0);
__decorate3([
  initial([]),
  signal()
], Shape.prototype, "lineDash", void 0);
__decorate3([
  initial(0),
  signal()
], Shape.prototype, "lineDashOffset", void 0);
__decorate3([
  initial(true),
  signal()
], Shape.prototype, "antialiased", void 0);
__decorate3([
  computed()
], Shape.prototype, "rippleSize", null);
__decorate3([
  computed()
], Shape.prototype, "getPath", null);
__decorate3([
  threadable()
], Shape.prototype, "ripple", null);

export {
  resolveCanvasStyle,
  drawRoundRect,
  drawPolygon,
  drawImage,
  moveTo,
  lineTo,
  drawLine,
  arc,
  bezierCurveTo,
  quadraticCurveTo,
  colorSignal,
  useScene2D,
  Node,
  spacingSignal,
  Layout,
  Shape
};
//# sourceMappingURL=chunk-B6CO33KU.js.map
