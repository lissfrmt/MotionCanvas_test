import {
  View2D
} from "./chunk-CULSV6BQ.js";
import {
  GeneratorScene,
  SceneRenderEvent,
  Vector2,
  createSceneMetadata
} from "./chunk-ZOQDAVQN.js";

// node_modules/@motion-canvas/2d/lib/scenes/Scene2D.js
var Scene2D = class extends GeneratorScene {
  constructor(description) {
    super(description);
    this.view = null;
    this.registeredNodes = {};
    this.nodeCounters = {};
    this.recreateView();
  }
  getView() {
    return this.view;
  }
  next() {
    var _a;
    (_a = this.getView()) == null ? void 0 : _a.playbackState(this.playback.state);
    return super.next();
  }
  draw(context) {
    context.save();
    this.renderLifecycle.dispatch([SceneRenderEvent.BeforeRender, context]);
    context.save();
    this.renderLifecycle.dispatch([SceneRenderEvent.BeginRender, context]);
    this.getView().playbackState(this.playback.state);
    this.getView().render(context);
    this.renderLifecycle.dispatch([SceneRenderEvent.FinishRender, context]);
    context.restore();
    this.renderLifecycle.dispatch([SceneRenderEvent.AfterRender, context]);
    context.restore();
  }
  reset(previousScene) {
    for (const key in this.registeredNodes) {
      try {
        this.registeredNodes[key].dispose();
      } catch (e) {
        this.logger.error(e);
      }
    }
    this.registeredNodes = {};
    this.nodeCounters = {};
    this.recreateView();
    return super.reset(previousScene);
  }
  inspectPosition(x, y) {
    return this.execute(() => {
      var _a;
      return ((_a = this.getView().hit(new Vector2(x, y).scale(this.resolutionScale))) == null ? void 0 : _a.key) ?? null;
    });
  }
  validateInspection(element) {
    var _a;
    return ((_a = this.getNode(element)) == null ? void 0 : _a.key) ?? null;
  }
  inspectAttributes(element) {
    const node = this.getNode(element);
    if (!node)
      return null;
    const attributes = {
      stack: node.creationStack,
      key: node.key
    };
    for (const { key, meta, signal } of node) {
      if (!meta.inspectable)
        continue;
      attributes[key] = signal();
    }
    return attributes;
  }
  drawOverlay(element, matrix, context) {
    const node = this.getNode(element);
    if (node) {
      this.execute(() => {
        node.drawOverlay(context, matrix.scale(1 / this.resolutionScale, 1 / this.resolutionScale).multiplySelf(node.localToWorld()));
      });
    }
  }
  registerNode(node, key) {
    var _a2;
    var _a;
    const className = ((_a2 = node.constructor) == null ? void 0 : _a2.name) ?? "unknown";
    (_a = this.nodeCounters)[className] ?? (_a[className] = 0);
    const counter = this.nodeCounters[className]++;
    key ?? (key = `${this.name}/${className}[${counter}]`);
    this.registeredNodes[key] = node;
    return key;
  }
  getNode(key) {
    if (typeof key !== "string")
      return null;
    return this.registeredNodes[key] ?? null;
  }
  recreateView() {
    this.execute(() => {
      const size = this.getSize();
      this.view = new View2D({
        position: size.scale(this.resolutionScale / 2),
        scale: this.resolutionScale,
        size
      });
    });
  }
};

// node_modules/@motion-canvas/2d/lib/scenes/makeScene2D.js
function makeScene2D(runner) {
  return {
    klass: Scene2D,
    config: runner,
    stack: new Error().stack,
    meta: createSceneMetadata()
  };
}

export {
  Scene2D,
  makeScene2D
};
//# sourceMappingURL=chunk-NXKDVICS.js.map
